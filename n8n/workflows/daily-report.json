{
  "name": "Daily Treasury Report",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 9 * * *"
            }
          ]
        }
      },
      "id": "trigger",
      "name": "Daily 9 AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [0, 0]
    },
    {
      "parameters": {
        "path": "daily-report",
        "httpMethod": "POST",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Dashboard Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 200],
      "webhookId": "daily-report-webhook"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Fetch Gateway balances from Circle REST API (accurate available balance)\nconst fetch = require('node-fetch');\nconst CIRCLE_GATEWAY_URL = $env.CIRCLE_GATEWAY_URL || 'https://gateway-api.circle.com';\nconst depositor = $env.TREASURY_ADDRESS;\n\nconst sources = [\n  { domain: 0, depositor },\n  { domain: 3, depositor },\n  { domain: 6, depositor },\n];\n\nconst response = await fetch(`${CIRCLE_GATEWAY_URL}/v1/balances`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ token: 'USDC', sources }),\n});\n\nif (!response.ok) {\n  const body = await response.text();\n  throw new Error(`Circle API error ${response.status}: ${body}`);\n}\n\nconst data = await response.json();\nreturn [{ json: { balances: data.balances, token: data.token } }];"
      },
      "id": "fetch-balance",
      "name": "Fetch Gateway Balance",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, -100],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://gateway.thegraph.com/api/{{ $env.GRAPH_API_KEY }}/subgraphs/id/{{ $env.GRAPH_SUBGRAPH_ARBITRUM || '5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"query\": \"{ bundles(first: 1) { ethPriceUSD } }\"\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "fetch-price",
      "name": "Fetch ETH Price (The Graph)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [220, 100],
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Fetch on-chain wallet balances (USDC + ETH) on each chain via JSON-RPC\nconst fetch = require('node-fetch');\nconst treasury = $env.TREASURY_ADDRESS;\n\nconst chains = [\n  { name: 'Ethereum', rpc: $env.RPC_ETHEREUM || 'https://eth.llamarpc.com', usdc: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' },\n  { name: 'Arbitrum', rpc: $env.RPC_ARBITRUM || 'https://arb1.arbitrum.io/rpc', usdc: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831' },\n  { name: 'Base', rpc: $env.RPC_BASE || 'https://mainnet.base.org', usdc: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913' },\n];\n\nconst balanceOfData = '0x70a08231' + treasury.slice(2).toLowerCase().padStart(64, '0');\n\nasync function rpcCall(rpc, method, params) {\n  const res = await fetch(rpc, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ jsonrpc: '2.0', id: 1, method, params }),\n  });\n  const data = await res.json();\n  return data.result || '0x0';\n}\n\nconst results = await Promise.all(chains.map(async (chain) => {\n  try {\n    const [ethHex, usdcHex] = await Promise.all([\n      rpcCall(chain.rpc, 'eth_getBalance', [treasury, 'latest']),\n      rpcCall(chain.rpc, 'eth_call', [{ to: chain.usdc, data: balanceOfData }, 'latest']),\n    ]);\n    const ethBalance = parseInt(ethHex, 16) / 1e18;\n    const usdcBalance = parseInt(usdcHex, 16) / 1e6;\n    return { chain: chain.name, ethBalance, usdcBalance };\n  } catch (err) {\n    return { chain: chain.name, ethBalance: 0, usdcBalance: 0 };\n  }\n}));\n\nreturn [{ json: { _type: 'wallet_balances', wallet_balances: results } }];"
      },
      "id": "fetch-wallet",
      "name": "Fetch Wallet Balances",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "append"
      },
      "id": "merge-gw-price",
      "name": "Merge Gateway + Price",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [350, 0]
    },
    {
      "parameters": {
        "mode": "append"
      },
      "id": "merge-all",
      "name": "Merge All",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [440, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Process merged data from Circle Gateway, The Graph, and wallet RPC\nconst items = $input.all();\n\nlet balanceData = {};\nlet priceData = {};\nlet walletData = [];\n\nfor (const item of items) {\n  const json = item.json || {};\n  if (json._type === 'wallet_balances') {\n    walletData = json.wallet_balances || [];\n  } else if (json.data?.bundles) {\n    priceData = json;\n  } else if (json.token === 'USDC' || json.balances || json.data?.balances) {\n    balanceData = json;\n  }\n}\n\n// Parse Circle Gateway balance â€” unified, chain-abstracted\nlet gatewayTotalUsdc = 0;\nconst balances = balanceData.balances || balanceData.data?.balances || [];\nfor (const bal of balances) {\n  gatewayTotalUsdc += parseFloat(bal.balance || bal.amount || '0');\n}\n\n// Parse ETH price\nlet ethPrice = 0;\nif (priceData.data?.bundles?.[0]) {\n  ethPrice = parseFloat(priceData.data.bundles[0].ethPriceUSD) || 0;\n}\n\nconst fmt = (n) => `$${n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;\nconst fmtEth = (n) => n.toFixed(6);\n\n// Build per-chain wallet breakdown (Gateway is unified, not per-chain)\nconst chainNames = ['Arbitrum', 'Base', 'Ethereum'];\nlet walletTotalUsdc = 0;\nlet walletTotalEthValue = 0;\nconst perChainLines = chainNames.map(name => {\n  const wl = walletData.find(w => w.chain === name);\n  const wlUsdc = wl?.usdcBalance || 0;\n  const wlEth = wl?.ethBalance || 0;\n  walletTotalUsdc += wlUsdc;\n  walletTotalEthValue += wlEth * ethPrice;\n  return `**${name}**\\n  USDC: ${fmt(wlUsdc)}\\n  ETH: ${fmtEth(wlEth)} (${fmt(wlEth * ethPrice)})`;\n}).join('\\n');\n\nconst totalPortfolio = gatewayTotalUsdc + walletTotalUsdc + walletTotalEthValue;\n\nreturn [{\n  json: {\n    title: 'Daily Treasury Report',\n    date: new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }),\n    totalPortfolio: fmt(totalPortfolio),\n    totalPortfolioRaw: totalPortfolio,\n    gatewayUsdc: fmt(gatewayTotalUsdc),\n    gatewayUsdcRaw: gatewayTotalUsdc,\n    walletUsdc: fmt(walletTotalUsdc),\n    walletEthValue: fmt(walletTotalEthValue),\n    ethPrice: fmt(ethPrice),\n    ethPriceRaw: ethPrice,\n    perChainBreakdown: perChainLines,\n    walletData,\n    timestamp: new Date().toISOString(),\n  }\n}];"
      },
      "id": "format-report",
      "name": "Format Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [550, 100]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_REPORTS }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"embeds\": [{\n    \"title\": \"{{ $json.title }}\",\n    \"description\": \"{{ $json.date }}\",\n    \"color\": 3447003,\n    \"fields\": [\n      {\n        \"name\": \"Total Portfolio\",\n        \"value\": \"{{ $json.totalPortfolio }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"ETH Price\",\n        \"value\": \"{{ $json.ethPrice }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Gateway USDC (unified)\",\n        \"value\": \"{{ $json.gatewayUsdc }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Wallet USDC (all chains)\",\n        \"value\": \"{{ $json.walletUsdc }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Wallet ETH Value\",\n        \"value\": \"{{ $json.walletEthValue }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Wallet Balances by Chain\",\n        \"value\": \"{{ $json.perChainBreakdown }}\"\n      }\n    ],\n    \"footer\": {\n      \"text\": \"PigAiBank | Gateway balance is chain-abstracted (spendable on any chain)\"\n    },\n    \"timestamp\": \"{{ $json.timestamp }}\"\n  }]\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "discord-report",
      "name": "Send to Discord",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [770, 0],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Save daily balance snapshot to Appwrite\nconst items = $input.all();\nconst data = items[0]?.json || {};\n\nconst endpoint = $env.APPWRITE_ENDPOINT;\nconst projectId = $env.APPWRITE_PROJECT_ID;\nconst apiKey = $env.APPWRITE_API_KEY;\nconst databaseId = $env.APPWRITE_DATABASE_ID || 'treasury';\n\nif (!endpoint || !apiKey) {\n  return [{ json: { saved: false, reason: 'Appwrite not configured', data: data } }];\n}\n\ntry {\n  const fetch = require('node-fetch');\n  const response = await fetch(\n    `${endpoint}/databases/${databaseId}/collections/balances/documents`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n      body: JSON.stringify({\n        documentId: 'unique()',\n        data: {\n          timestamp: data.timestamp || new Date().toISOString(),\n          total_usd: String(data.totalPortfolioRaw || 0),\n          gateway_usd: String(data.gatewayUsdcRaw || 0),\n          wallet_balances: JSON.stringify(data.walletData || []),\n          eth_price: String(data.ethPriceRaw || 0),\n          source: 'daily_report',\n        },\n      }),\n    }\n  );\n  const result = await response.json();\n  return [{ json: { saved: true, documentId: result.$id, data: data } }];\n} catch (error) {\n  return [{ json: { saved: false, reason: error.message, data: data } }];\n}"
      },
      "id": "save-appwrite",
      "name": "Save to Appwrite",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [770, 200]
    }
  ],
  "connections": {
    "Daily 9 AM": {
      "main": [
        [
          { "node": "Fetch Gateway Balance", "type": "main", "index": 0 },
          { "node": "Fetch ETH Price (The Graph)", "type": "main", "index": 0 },
          { "node": "Fetch Wallet Balances", "type": "main", "index": 0 }
        ]
      ]
    },
    "Dashboard Trigger": {
      "main": [
        [
          { "node": "Fetch Gateway Balance", "type": "main", "index": 0 },
          { "node": "Fetch ETH Price (The Graph)", "type": "main", "index": 0 },
          { "node": "Fetch Wallet Balances", "type": "main", "index": 0 }
        ]
      ]
    },
    "Fetch Gateway Balance": {
      "main": [
        [{ "node": "Merge Gateway + Price", "type": "main", "index": 0 }]
      ]
    },
    "Fetch ETH Price (The Graph)": {
      "main": [
        [{ "node": "Merge Gateway + Price", "type": "main", "index": 1 }]
      ]
    },
    "Merge Gateway + Price": {
      "main": [
        [{ "node": "Merge All", "type": "main", "index": 0 }]
      ]
    },
    "Fetch Wallet Balances": {
      "main": [
        [{ "node": "Merge All", "type": "main", "index": 1 }]
      ]
    },
    "Merge All": {
      "main": [
        [{ "node": "Format Report", "type": "main", "index": 0 }]
      ]
    },
    "Format Report": {
      "main": [
        [
          { "node": "Send to Discord", "type": "main", "index": 0 },
          { "node": "Save to Appwrite", "type": "main", "index": 0 }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "pinData": {}
}
