{
  "name": "Weekly Summary",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 8 * * 1"
            }
          ]
        }
      },
      "id": "trigger",
      "name": "Monday 8 AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [0, 0]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Fetch price history from Appwrite for the past week\nconst endpoint = $env.APPWRITE_ENDPOINT;\nconst projectId = $env.APPWRITE_PROJECT_ID;\nconst apiKey = $env.APPWRITE_API_KEY;\nconst databaseId = $env.APPWRITE_DATABASE_ID || 'treasury';\n\nconst weekAgo = new Date();\nweekAgo.setDate(weekAgo.getDate() - 7);\n\nif (!endpoint || !apiKey) {\n  // Return mock data for testing\n  return [{\n    json: {\n      prices: [\n        { price_usd: 3100 },\n        { price_usd: 3200 },\n        { price_usd: 3150 },\n        { price_usd: 3250 },\n        { price_usd: 3180 },\n      ],\n      token: 'ETH',\n      source: 'mock',\n    }\n  }];\n}\n\ntry {\n  const response = await fetch(\n    `${endpoint}/databases/${databaseId}/collections/price_history/documents?` +\n    new URLSearchParams({\n      queries: JSON.stringify([\n        `greaterThan(\"timestamp\", \"${weekAgo.toISOString()}\")`,\n        'equal(\"token\", \"ETH\")',\n        'orderDesc(\"timestamp\")',\n        'limit(1000)',\n      ]),\n    }),\n    {\n      headers: {\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n    }\n  );\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    return [{ json: { prices: [], token: 'ETH', source: 'error', error: errorText } }];\n  }\n\n  const data = await response.json();\n\n  return [{\n    json: {\n      prices: data.documents || [],\n      token: 'ETH',\n      source: 'appwrite',\n    }\n  }];\n} catch (error) {\n  return [{ json: { prices: [], token: 'ETH', source: 'error', error: error.message } }];\n}"
      },
      "id": "fetch-history",
      "name": "Fetch Price History",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, -100]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Fetch execution history from Appwrite\nconst endpoint = $env.APPWRITE_ENDPOINT;\nconst projectId = $env.APPWRITE_PROJECT_ID;\nconst apiKey = $env.APPWRITE_API_KEY;\nconst databaseId = $env.APPWRITE_DATABASE_ID || 'treasury';\n\nconst weekAgo = new Date();\nweekAgo.setDate(weekAgo.getDate() - 7);\n\nif (!endpoint || !apiKey) {\n  return [{\n    json: {\n      executions: [],\n      totalVolume: 0,\n      count: 0,\n      completedCount: 0,\n      failedCount: 0,\n      source: 'mock',\n    }\n  }];\n}\n\ntry {\n  const response = await fetch(\n    `${endpoint}/databases/${databaseId}/collections/executions/documents?` +\n    new URLSearchParams({\n      queries: JSON.stringify([\n        `greaterThan(\"timestamp\", \"${weekAgo.toISOString()}\")`,\n        'orderDesc(\"timestamp\")',\n        'limit(100)',\n      ]),\n    }),\n    {\n      headers: {\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n    }\n  );\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    return [{ json: { executions: [], totalVolume: 0, count: 0, completedCount: 0, failedCount: 0, cancelledCount: 0, mockedCount: 0, source: 'error', error: errorText } }];\n  }\n\n  const data = await response.json();\n  const executions = data.documents || [];\n\n  // Calculate totals\n  let totalVolume = 0;\n  let completedCount = 0;\n  let failedCount = 0;\n  let cancelledCount = 0;\n  let mockedCount = 0;\n\n  for (const exec of executions) {\n    if (exec.amount_usd) {\n      totalVolume += parseFloat(exec.amount_usd) || 0;\n    }\n    if (exec.status === 'completed') completedCount++;\n    if (exec.status === 'failed') failedCount++;\n    if (exec.status === 'cancelled') cancelledCount++;\n    if (exec.mocked === true) mockedCount++;\n  }\n\n  return [{\n    json: {\n      executions,\n      totalVolume,\n      count: executions.length,\n      completedCount,\n      failedCount,\n      cancelledCount,\n      mockedCount,\n      source: 'appwrite',\n    }\n  }];\n} catch (error) {\n  return [{ json: { executions: [], totalVolume: 0, count: 0, completedCount: 0, failedCount: 0, cancelledCount: 0, mockedCount: 0, source: 'error', error: error.message } }];\n}"
      },
      "id": "fetch-executions",
      "name": "Fetch Executions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Calculate statistics and format report\n// Get data from both fetch nodes\nlet priceData, execData;\n\ntry {\n  priceData = $('Fetch Price History').first()?.json || { prices: [], token: 'ETH' };\n} catch (e) {\n  priceData = { prices: [], token: 'ETH' };\n}\n\ntry {\n  execData = $('Fetch Executions').first()?.json || { executions: [], totalVolume: 0, count: 0 };\n} catch (e) {\n  execData = { executions: [], totalVolume: 0, count: 0, completedCount: 0, failedCount: 0, cancelledCount: 0, mockedCount: 0 };\n}\n\nconst prices = (priceData.prices || []).map(p => p.price_usd).filter(p => p > 0);\n\nlet stats = {\n  high: 0,\n  low: 0,\n  average: 0,\n  volatility: 0,\n  change: 0,\n  changePercent: 0,\n};\n\nif (prices.length > 0) {\n  stats.high = Math.max(...prices);\n  stats.low = Math.min(...prices);\n  stats.average = prices.reduce((a, b) => a + b, 0) / prices.length;\n  \n  // Calculate volatility (standard deviation as % of mean)\n  const mean = stats.average;\n  const squareDiffs = prices.map(p => Math.pow(p - mean, 2));\n  const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;\n  const stdDev = Math.sqrt(avgSquareDiff);\n  stats.volatility = (stdDev / mean) * 100;\n\n  // Calculate week-over-week change (first vs last price)\n  if (prices.length >= 2) {\n    const newest = prices[0]; // Most recent (sorted desc)\n    const oldest = prices[prices.length - 1]; // Oldest in range\n    stats.change = newest - oldest;\n    stats.changePercent = ((newest - oldest) / oldest) * 100;\n  }\n}\n\nconst formatCurrency = (n) => `$${n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;\nconst formatChange = (n, pct) => {\n  const sign = n >= 0 ? '+' : '';\n  return `${sign}${formatCurrency(n)} (${sign}${pct.toFixed(2)}%)`;\n};\n\n// Determine execution mode indicator\nconst executionMode = $env.EXECUTION_MODE || 'mock';\nconst modeIndicator = executionMode === 'live' ? 'LIVE' : 'MOCK';\n\nreturn [{\n  json: {\n    token: priceData.token || 'ETH',\n    priceHigh: formatCurrency(stats.high),\n    priceLow: formatCurrency(stats.low),\n    priceAvg: formatCurrency(stats.average),\n    priceChange: formatChange(stats.change, stats.changePercent),\n    volatility: stats.volatility.toFixed(2) + '%',\n    totalVolume: formatCurrency(execData.totalVolume || 0),\n    executionCount: execData.count || 0,\n    completedCount: execData.completedCount || 0,\n    failedCount: execData.failedCount || 0,\n    cancelledCount: execData.cancelledCount || 0,\n    mockedCount: execData.mockedCount || 0,\n    dataPoints: prices.length,\n    weekStart: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toLocaleDateString(),\n    weekEnd: new Date().toLocaleDateString(),\n    executionMode: modeIndicator,\n    timestamp: new Date().toISOString(),\n  }\n}];"
      },
      "id": "calculate-stats",
      "name": "Calculate Statistics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 0]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_REPORTS }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"embeds\": [{\n    \"title\": \"Weekly Performance Summary\",\n    \"description\": \"{{ $json.weekStart }} - {{ $json.weekEnd }} | Mode: **{{ $json.executionMode }}**\",\n    \"color\": 5814783,\n    \"fields\": [\n      {\n        \"name\": \"{{ $json.token }} Price Range\",\n        \"value\": \"High: {{ $json.priceHigh }}\\nLow: {{ $json.priceLow }}\\nAvg: {{ $json.priceAvg }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Week Change\",\n        \"value\": \"{{ $json.priceChange }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Volatility\",\n        \"value\": \"{{ $json.volatility }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Execution Volume\",\n        \"value\": \"{{ $json.totalVolume }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Executions\",\n        \"value\": \"{{ $json.executionCount }} total\\n{{ $json.completedCount }} completed\\n{{ $json.failedCount }} failed\\n{{ $json.cancelledCount }} cancelled\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Data Points\",\n        \"value\": \"{{ $json.dataPoints }} price samples\",\n        \"inline\": true\n      }\n    ],\n    \"footer\": {\n      \"text\": \"Treasury Ops Bot | Data: The Graph + Appwrite\"\n    },\n    \"timestamp\": \"{{ $json.timestamp }}\"\n  }]\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "discord-summary",
      "name": "Send to Discord",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [660, 0],
      "onError": "continueRegularOutput"
    }
  ],
  "connections": {
    "Monday 8 AM": {
      "main": [
        [
          { "node": "Fetch Price History", "type": "main", "index": 0 },
          { "node": "Fetch Executions", "type": "main", "index": 0 }
        ]
      ]
    },
    "Fetch Price History": {
      "main": [
        [{ "node": "Calculate Statistics", "type": "main", "index": 0 }]
      ]
    },
    "Fetch Executions": {
      "main": [
        [{ "node": "Calculate Statistics", "type": "main", "index": 0 }]
      ]
    },
    "Calculate Statistics": {
      "main": [
        [{ "node": "Send to Discord", "type": "main", "index": 0 }]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "pinData": {}
}
