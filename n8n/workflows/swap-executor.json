{
  "name": "Swap Executor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "swap-executor",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook",
      "name": "Swap Request Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        0
      ],
      "webhookId": "swap-executor",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Validate swap request, resolve ENS names, and determine routing\nconst fetch = require('node-fetch');\nconst items = $input.all();\nconst body = items[0]?.json?.body || {};\n\nconst required = ['sourceChain', 'destChain', 'sourceToken', 'destToken', 'amount'];\nconst missing = required.filter(f => !body[f]);\n\nif (missing.length > 0) {\n  throw new Error(`Missing required fields: ${missing.join(', ')}`);\n}\n\nconst amount = parseFloat(body.amount);\nif (isNaN(amount) || amount <= 0) {\n  throw new Error('Invalid amount');\n}\n\n// ENS Resolution helper\nconst resolveENS = async (nameOrAddress) => {\n  if (!nameOrAddress) return null;\n  \n  // Already an address\n  if (nameOrAddress.startsWith('0x') && nameOrAddress.length === 42) {\n    return { address: nameOrAddress, ensName: null, resolved: false };\n  }\n  \n  // ENS name - resolve it\n  if (nameOrAddress.endsWith('.eth')) {\n    try {\n      // Use ENS subgraph via The Graph decentralized network\n      const ensSubgraphId = '5XqPmWe6gjyrJtFn9cLy237i4cWw2j9HcUJEXsP5qGtH';\n      const graphApiKey = $env.GRAPH_API_KEY;\n      if (!graphApiKey) throw new Error('GRAPH_API_KEY required for ENS resolution');\n      const ensEndpoint = `https://gateway.thegraph.com/api/${graphApiKey}/subgraphs/id/${ensSubgraphId}`;\n      const response = await fetch(ensEndpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          query: `{ domains(where: { name: \"${nameOrAddress}\" }) { resolvedAddress { id } } }`\n        })\n      });\n      const data = await response.json();\n      const address = data?.data?.domains?.[0]?.resolvedAddress?.id;\n      if (address) {\n        return { address, ensName: nameOrAddress, resolved: true };\n      }\n    } catch (e) {\n      // Fallback: try mainnet RPC\n    }\n    throw new Error(`Could not resolve ENS name: ${nameOrAddress}`);\n  }\n  \n  throw new Error(`Invalid address or ENS name: ${nameOrAddress}`);\n};\n\n// Resolve recipient if provided (supports ENS names like \"vitalik.eth\")\nlet recipient = null;\nlet recipientENS = null;\nif (body.recipient) {\n  const resolved = await resolveENS(body.recipient);\n  recipient = resolved.address;\n  recipientENS = resolved.ensName;\n}\n\n// Normalize chain names\nconst normalizeChain = (chain) => chain.toLowerCase().replace(/[_\\-\\s]/g, '');\nconst sourceChain = normalizeChain(body.sourceChain);\nconst destChain = normalizeChain(body.destChain);\n\n// Chain ID mapping\nconst chainIds = {\n  'base': 8453,\n  'arbitrum': 42161,\n  'optimism': 10,\n  'ethereum': 1,\n  'polygon': 137,\n  // Testnets\n  'basesepolia': 84532,\n  'arbitrumsepolia': 421614,\n  'sepolia': 11155111,\n};\n\nconst sourceChainId = chainIds[sourceChain];\nconst destChainId = chainIds[destChain];\n\nif (!sourceChainId || !destChainId) {\n  throw new Error(`Unknown chain: ${!sourceChainId ? body.sourceChain : body.destChain}`);\n}\n\n// Determine if testnet\nconst isTestnet = [84532, 421614, 11155111].includes(sourceChainId) || \n                  [84532, 421614, 11155111].includes(destChainId);\n\n// Determine routing\nconst isCrossChain = sourceChainId !== destChainId;\nconst isUsdcOnly = body.sourceToken.toUpperCase() === 'USDC' && body.destToken.toUpperCase() === 'USDC';\n\nlet route = 'uniswap'; // Default: same-chain swap\nif (isCrossChain) {\n  if (isUsdcOnly) {\n    route = 'gateway'; // Circle Gateway for USDC-only cross-chain\n  } else {\n    route = 'lifi'; // LI.FI for cross-chain with swap\n  }\n}\n\n// Get execution mode\nconst executionMode = $env.EXECUTION_MODE || 'mock';\n\nreturn [{\n  json: {\n    ...body,\n    amount,\n    sourceChain,\n    destChain,\n    sourceChainId,\n    destChainId,\n    route,\n    isCrossChain,\n    isTestnet,\n    isUsdcOnly,\n    executionMode,\n    recipient,\n    recipientENS,\n    timestamp: new Date().toISOString(),\n  }\n}];"
      },
      "id": "validate",
      "name": "Validate Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        0
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Prepare Appwrite document body from validated request\n// Only include attributes that exist in the Appwrite 'executions' collection schema\nconst data = $input.first().json;\n\n// Map internal route names to Appwrite enum values (gateway \u2192 circle)\nconst routeMap = { 'gateway': 'circle', 'uniswap': 'uniswap', 'lifi': 'lifi' };\nconst appwriteRoute = routeMap[data.route] || data.route;\n\nreturn [{\n  json: {\n    ...data,\n    appwriteRoute,\n  }\n}];"
      },
      "id": "prepare-execution-data",
      "name": "Prepare Execution Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        440,
        0
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.APPWRITE_ENDPOINT }}/databases/{{ $env.APPWRITE_DATABASE_ID || 'treasury' }}/collections/executions/documents",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Appwrite-Project",
              "value": "={{ $env.APPWRITE_PROJECT_ID }}"
            },
            {
              "name": "X-Appwrite-Key",
              "value": "={{ $env.APPWRITE_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"documentId\": \"unique()\",\n  \"data\": {\n    \"timestamp\": \"{{ $json.timestamp }}\",\n    \"type\": \"swap\",\n    \"source_chain\": \"{{ $json.sourceChain }}\",\n    \"dest_chain\": \"{{ $json.destChain }}\",\n    \"source_token\": \"{{ $json.sourceToken.toUpperCase() }}\",\n    \"dest_token\": \"{{ $json.destToken.toUpperCase() }}\",\n    \"amount\": \"{{ $json.amount }}\",\n    \"status\": \"pending\",\n    \"route\": \"{{ $json.appwriteRoute }}\",\n    \"reason\": \"{{ $json.reason || '' }}\",\n    \"requester\": \"webhook\"\n  }\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "save-to-appwrite",
      "name": "Save to Appwrite",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [
        660,
        0
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Extract the Appwrite document ID and merge with original request data\nconst appwriteResponse = $input.first().json;\nconst requestData = $('Prepare Execution Data').first().json;\n\n// If Appwrite returned a $id, use it; otherwise fallback to local ID\nconst executionId = appwriteResponse.$id || 'local-' + Date.now();\n\nreturn [{\n  json: {\n    ...requestData,\n    executionId,\n  }\n}];"
      },
      "id": "extract-execution-id",
      "name": "Extract Execution ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        0
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_REPORTS }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"embeds\": [{\n    \"title\": \"Swap Request Received\",\n    \"description\": \"A new swap request is pending confirmation.{{ $json.recipientENS ? ' (ENS: ' + $json.recipientENS + ' resolved!)' : '' }}\",\n    \"color\": 3447003,\n    \"fields\": [\n      {\n        \"name\": \"From\",\n        \"value\": \"{{ $json.amount }} {{ $json.sourceToken }} on {{ $json.sourceChain }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"To\",\n        \"value\": \"{{ $json.destToken }} on {{ $json.destChain }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Route\",\n        \"value\": \"{{ $json.route }}{{ $json.isCrossChain ? ' (cross-chain)' : ' (same-chain)' }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Mode\",\n        \"value\": \"{{ $json.executionMode.toUpperCase() }}{{ $json.isTestnet ? ' (testnet)' : '' }}\",\n        \"inline\": true\n      },\n      {{ $json.recipient ? '{\"name\": \"Recipient\", \"value\": \"' + ($json.recipientENS ? $json.recipientENS + ' \u2192 ' : '') + '`' + $json.recipient.substring(0,10) + '...`\", \"inline\": true},' : '' }}\n      {\n        \"name\": \"Execution ID\",\n        \"value\": \"`{{ $json.executionId }}`\"\n      }\n    ],\n    \"footer\": {\n      \"text\": \"POST /webhook/swap-confirm to execute or cancel\"\n    },\n    \"timestamp\": \"{{ $json.timestamp }}\"\n  }]\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "notify-discord",
      "name": "Notify Discord",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [
        1100,
        0
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"executionId\": \"{{ $('Extract Execution ID').first().json.executionId }}\",\n  \"status\": \"pending\",\n  \"message\": \"Swap request created. POST to /webhook/swap-confirm to execute.\",\n  \"route\": \"{{ $('Extract Execution ID').first().json.route }}\",\n  \"executionMode\": \"{{ $('Extract Execution ID').first().json.executionMode }}\",\n  \"isTestnet\": {{ $('Extract Execution ID').first().json.isTestnet ? 'true' : 'false' }}\n}"
      },
      "id": "respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1320,
        0
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "swap-confirm",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "confirm-webhook",
      "name": "Confirm Swap Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        300
      ],
      "webhookId": "swap-confirm",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Parse confirm/cancel request - extract executionId and action\nconst body = $input.first().json.body || {};\nconst { executionId, action } = body;\n\nif (!executionId) {\n  throw new Error('executionId is required');\n}\n\nreturn [{\n  json: {\n    executionId,\n    action: action || 'confirm',\n    cancelled: action === 'cancel',\n  }\n}];"
      },
      "id": "parse-confirm-request",
      "name": "Parse Confirm Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "condition-cancelled",
              "leftValue": "={{ $json.cancelled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-cancelled",
      "name": "Cancelled?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        440,
        300
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "={{ $env.APPWRITE_ENDPOINT }}/databases/{{ $env.APPWRITE_DATABASE_ID || 'treasury' }}/collections/executions/documents/{{ $json.executionId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Appwrite-Project",
              "value": "={{ $env.APPWRITE_PROJECT_ID }}"
            },
            {
              "name": "X-Appwrite-Key",
              "value": "={{ $env.APPWRITE_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"data\": {\n    \"status\": \"cancelled\",\n    \"completed_at\": \"{{ $now.toISO() }}\"\n  }\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "cancel-in-appwrite",
      "name": "Cancel in Appwrite",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [
        660,
        200
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Format cancel response for webhook\nconst executionId = $('Parse Confirm Request').first().json.executionId;\n\nreturn [{\n  json: {\n    cancelled: true,\n    executionId,\n  }\n}];"
      },
      "id": "format-cancel-response",
      "name": "Format Cancel Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        200
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"executionId\": \"{{ $json.executionId }}\",\n  \"status\": \"cancelled\"\n}"
      },
      "id": "respond-cancel",
      "name": "Respond Cancel",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1100,
        200
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.APPWRITE_ENDPOINT }}/databases/{{ $env.APPWRITE_DATABASE_ID || 'treasury' }}/collections/executions/documents/{{ $json.executionId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "X-Appwrite-Project",
              "value": "={{ $env.APPWRITE_PROJECT_ID }}"
            },
            {
              "name": "X-Appwrite-Key",
              "value": "={{ $env.APPWRITE_API_KEY }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "fetch-execution-appwrite",
      "name": "Fetch Execution from Appwrite",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [
        660,
        400
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Merge confirm request data with fetched execution document\nconst execution = $input.first().json;\nconst requestData = $('Parse Confirm Request').first().json;\n\nif (!execution.$id) {\n  throw new Error(`Execution not found: ${requestData.executionId}`);\n}\n\nreturn [{\n  json: {\n    executionId: requestData.executionId,\n    cancelled: false,\n    execution,\n    executionMode: $env.EXECUTION_MODE || 'mock',\n  }\n}];"
      },
      "id": "merge-confirm-data",
      "name": "Merge Confirm Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        880,
        400
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Execute swap with smart routing: Uniswap (same-chain), LI.FI (cross-chain), Gateway (USDC)\nconst fetch = require('node-fetch');\nconst items = $input.all();\nconst data = items[0]?.json || {};\nconst exec = data.execution || {};\nconst executionMode = data.executionMode || 'mock';\n\nconst route = exec.route;\nlet txHash = null;\nlet error = null;\nlet mocked = false;\nlet quote = null;\n\n// Chain ID mapping\nconst chainIds = {\n  'base': 8453,\n  'arbitrum': 42161,\n  'optimism': 10,\n  'ethereum': 1,\n  'polygon': 137,\n};\n\n// Uniswap v3 subgraph IDs per chain (The Graph decentralized network)\nconst uniswapSubgraphs = {\n  8453: '43Hwfi3dJSoGpyas9VwNoDAv55yjgGrPpNSmbQZArzMG',  // Base\n  42161: 'FbCGRftH4a3yZugY7TnbYgPJVEv2LvMT6oF1fxPe9aJM', // Arbitrum\n  10: 'Cghf4LfVqPiFw6fp6Y5X5Ubc8UpmUhSfJL82zwiBFLaj',   // Optimism\n  1: '5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV',    // Ethereum\n};\n\nconst sourceChainId = chainIds[exec.source_chain] || 8453;\nconst destChainId = chainIds[exec.dest_chain] || 8453;\n\n// Token addresses (mainnet)\nconst tokenAddresses = {\n  'USDC': {\n    8453: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\n    42161: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',\n    10: '0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85',\n    1: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n  },\n  'WETH': {\n    8453: '0x4200000000000000000000000000000000000006',\n    42161: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',\n    10: '0x4200000000000000000000000000000000000006',\n    1: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n  },\n  'ETH': {\n    8453: '0x4200000000000000000000000000000000000006',\n    42161: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',\n    10: '0x4200000000000000000000000000000000000006',\n    1: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n  },\n};\n\nconst getTokenAddress = (symbol, chainId) => {\n  const upper = symbol?.toUpperCase();\n  return tokenAddresses[upper]?.[chainId] || symbol;\n};\n\nconst getTokenDecimals = (symbol) => {\n  return symbol?.toUpperCase() === 'USDC' ? 6 : 18;\n};\n\ntry {\n  if (route === 'uniswap') {\n    // DIRECT UNISWAP INTEGRATION - Same-chain swaps via Uniswap v3\n    const graphApiKey = $env.GRAPH_API_KEY;\n    const subgraphId = uniswapSubgraphs[sourceChainId];\n    \n    if (!graphApiKey) {\n      throw new Error('GRAPH_API_KEY required for Uniswap integration');\n    }\n    \n    const fromToken = getTokenAddress(exec.source_token, sourceChainId).toLowerCase();\n    const toToken = getTokenAddress(exec.dest_token, sourceChainId).toLowerCase();\n    const fromDecimals = getTokenDecimals(exec.source_token);\n    const toDecimals = getTokenDecimals(exec.dest_token);\n    const inputAmount = parseFloat(exec.amount);\n    \n    // Query Uniswap v3 subgraph for pool data and price\n    // In Uniswap v3, token0 is always the lower address\n    const [sortedToken0, sortedToken1] = [fromToken, toToken].sort();\n    const poolQuery = `{\n      pools(\n        first: 1,\n        where: {\n          token0: \"${sortedToken0}\",\n          token1: \"${sortedToken1}\"\n        },\n        orderBy: totalValueLockedUSD,\n        orderDirection: desc\n      ) {\n        id\n        token0 { id symbol decimals }\n        token1 { id symbol decimals }\n        token0Price\n        token1Price\n        feeTier\n        liquidity\n        totalValueLockedUSD\n      }\n    }`;\n    \n    const graphResponse = await fetch(\n      `https://gateway.thegraph.com/api/${graphApiKey}/subgraphs/id/${subgraphId}`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ query: poolQuery })\n      }\n    );\n    \n    const graphData = await graphResponse.json();\n    const pool = graphData?.data?.pools?.[0];\n    \n    if (!pool) {\n      throw new Error(`No Uniswap pool found for ${exec.source_token}/${exec.dest_token} on chain ${sourceChainId}`);\n    }\n    \n    // Calculate output amount based on pool price\n    const isToken0Input = pool.token0.id.toLowerCase() === fromToken;\n    const price = isToken0Input ? parseFloat(pool.token1Price) : parseFloat(pool.token0Price);\n    const outputAmount = inputAmount * price;\n    \n    // Apply slippage (0.5%)\n    const slippage = 0.005;\n    const minOutput = outputAmount * (1 - slippage);\n    \n    quote = {\n      provider: 'uniswap_v3_direct',\n      pool: pool.id,\n      feeTier: pool.feeTier,\n      fromToken: exec.source_token,\n      toToken: exec.dest_token,\n      fromAmount: inputAmount.toString(),\n      fromAmountWei: (inputAmount * Math.pow(10, fromDecimals)).toString(),\n      toAmount: outputAmount.toFixed(toDecimals === 6 ? 6 : 8),\n      toAmountMin: minOutput.toFixed(toDecimals === 6 ? 6 : 8),\n      price: price.toString(),\n      priceImpact: 'calculated_from_pool',\n      liquidityUSD: pool.totalValueLockedUSD,\n      chain: exec.source_chain,\n      chainId: sourceChainId,\n    };\n    \n    if (executionMode === 'mock') {\n      mocked = true;\n      txHash = `0xmock_uniswap_${sourceChainId}_${Date.now().toString(16)}_${Math.random().toString(16).slice(2, 10)}`;\n    } else {\n      // Live mode: Build Universal Router transaction\n      // This would require encoding the swap call for Universal Router contract\n      // Live mode: Gateway mint + Uniswap swap via GatewaySwapReceiver\n      const ethers = require('ethers');\n      const treasuryKey = $env.TREASURY_PRIVATE_KEY;\n      if (!treasuryKey) throw new Error('TREASURY_PRIVATE_KEY required for live execution');\n\n      const rpcUrls = { 8453: $env.RPC_BASE || 'https://mainnet.base.org', 42161: $env.RPC_ARBITRUM || 'https://arb1.arbitrum.io/rpc', 1: 'https://eth.llamarpc.com' };\n      const provider = new ethers.JsonRpcProvider(rpcUrls[sourceChainId]);\n      const wallet = new ethers.Wallet(treasuryKey, provider);\n\n      // GatewaySwapReceiver addresses (update after deployment)\n      const receiverAddresses = { 42161: $env.GATEWAY_SWAP_RECEIVER_ARB || '0x0000000000000000000000000000000000000000', 8453: $env.GATEWAY_SWAP_RECEIVER_BASE || '0x0000000000000000000000000000000000000000' };\n      const receiverAddr = receiverAddresses[sourceChainId];\n      if (!receiverAddr || receiverAddr === '0x0000000000000000000000000000000000000000') throw new Error('GatewaySwapReceiver not deployed on chain ' + sourceChainId);\n\n      // 1. Sign EIP-712 BurnIntent\n      const gatewayWallet = '0x77777777Dcc4d5A8B6E418Fd04D8997ef11000eE';\n      const circleDomains = { 1: 0, 42161: 3, 8453: 6 };\n      const sourceDomain = circleDomains[sourceChainId];\n      const addrToBytes32 = (a) => '0x' + a.replace('0x','').toLowerCase().padStart(64,'0');\n      const salt = '0x' + [...Array(32)].map(() => Math.floor(Math.random()*256).toString(16).padStart(2,'0')).join('');\n\n      const domain = { name: 'GatewayWallet', version: '1' };\n      const types = { TransferSpec: [ { name:'version',type:'uint8' }, { name:'sourceDomain',type:'uint32' }, { name:'destinationDomain',type:'uint32' }, { name:'sourceContract',type:'bytes32' }, { name:'destinationContract',type:'bytes32' }, { name:'sourceToken',type:'bytes32' }, { name:'destinationToken',type:'bytes32' }, { name:'sourceDepositor',type:'bytes32' }, { name:'destinationRecipient',type:'bytes32' }, { name:'sourceSigner',type:'bytes32' }, { name:'destinationCaller',type:'bytes32' }, { name:'value',type:'uint256' }, { name:'salt',type:'bytes32' }, { name:'hookData',type:'bytes' } ] };\n      const transferSpec = {\n        version: 1, sourceDomain, destinationDomain: sourceDomain,\n        sourceContract: addrToBytes32(gatewayWallet), destinationContract: addrToBytes32(gatewayWallet),\n        sourceToken: addrToBytes32(fromToken), destinationToken: addrToBytes32(fromToken),\n        sourceDepositor: addrToBytes32(wallet.address), destinationRecipient: addrToBytes32(receiverAddr),\n        sourceSigner: addrToBytes32(wallet.address), destinationCaller: addrToBytes32(receiverAddr),\n        value: ethers.parseUnits(exec.amount, fromDecimals), salt, hookData: '0x'\n      };\n\n      const signature = await wallet.signTypedData(domain, types, transferSpec);\n\n      // 2. Submit to Circle API\n      const circleUrl = $env.CIRCLE_GATEWAY_URL || 'https://gateway-api.circle.com';\n      const circleKey = $env.CIRCLE_API_KEY;\n      const transferResp = await fetch(`${circleUrl}/v1/transfer`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json', ...(circleKey ? { 'Authorization': `Bearer ${circleKey}` } : {}) },\n        body: JSON.stringify({ transferSpec: { ...transferSpec, value: transferSpec.value.toString() }, signature })\n      });\n      const transferData = await transferResp.json();\n      if (!transferResp.ok) throw new Error('Circle API: ' + JSON.stringify(transferData));\n\n      // 3. Poll for attestation\n      let attestation = null;\n      for (let i = 0; i < 60; i++) {\n        const pollResp = await fetch(`${circleUrl}/v1/transfer/${transferData.transferId}`, {\n          headers: circleKey ? { 'Authorization': `Bearer ${circleKey}` } : {}\n        });\n        const pollData = await pollResp.json();\n        if (pollData.attestation && pollData.signature) { attestation = pollData; break; }\n        if (pollData.status === 'failed') throw new Error('Transfer failed: ' + (pollData.error || 'unknown'));\n        await new Promise(r => setTimeout(r, 2000));\n      }\n      if (!attestation) throw new Error('Attestation polling timed out');\n\n      // 4. Build Universal Router commands and call GatewaySwapReceiver\n      const universalRouters = { 42161: '0xa51afafe0263b40edaef0df8781ea9aa03e381a3', 8453: '0x6ff5693b99212da76ad316178a184ab56d299b43' };\n      const wethAddresses = { 42161: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1', 8453: '0x4200000000000000000000000000000000000006' };\n      const weth = wethAddresses[sourceChainId];\n      const isOutputEth = toToken.toLowerCase() === weth.toLowerCase();\n      const feeTier = 500; // USDC/WETH 0.05%\n      const amountInWei = ethers.parseUnits(exec.amount, fromDecimals);\n      const amountOutMinWei = ethers.parseUnits(quote.toAmountMin, toDecimals);\n\n      // Encode v3 path: tokenIn(20) + fee(3) + tokenOut(20)\n      const pathBytes = ethers.concat([ fromToken, ethers.toBeHex(feeTier, 3), isOutputEth ? weth : toToken ]);\n      const abiCoder = ethers.AbiCoder.defaultAbiCoder();\n\n      let commands, inputs;\n      if (isOutputEth) {\n        const ADDRESS_THIS = '0x0000000000000000000000000000000000000002';\n        const swapInput = abiCoder.encode(['address','uint256','uint256','bytes','bool'], [ADDRESS_THIS, amountInWei, amountOutMinWei, pathBytes, false]);\n        const unwrapInput = abiCoder.encode(['address','uint256'], [wallet.address, amountOutMinWei]);\n        commands = ethers.concat([ethers.toBeHex(0x00, 1), ethers.toBeHex(0x0c, 1)]);\n        inputs = [swapInput, unwrapInput];\n      } else {\n        const swapInput = abiCoder.encode(['address','uint256','uint256','bytes','bool'], [wallet.address, amountInWei, amountOutMinWei, pathBytes, false]);\n        commands = ethers.toBeHex(0x00, 1);\n        inputs = [swapInput];\n      }\n\n      const deadline = Math.floor(Date.now() / 1000) + 1800;\n      const outputToken = isOutputEth ? '0x0000000000000000000000000000000000000000' : toToken;\n\n      const receiverAbi = ['function executeSwap(bytes,bytes,bytes,bytes[],uint256,address,address)'];\n      const receiver = new ethers.Contract(receiverAddr, receiverAbi, wallet);\n      const tx = await receiver.executeSwap(attestation.attestation, attestation.signature, commands, inputs, deadline, outputToken, wallet.address);\n      const receipt = await tx.wait();\n      txHash = receipt.hash;\n    }\n    \n  } else if (route === 'lifi') {\n    // LI.FI for cross-chain swaps\n    const fromToken = getTokenAddress(exec.source_token, sourceChainId);\n    const toToken = getTokenAddress(exec.dest_token, destChainId);\n    const fromAmount = (parseFloat(exec.amount) * Math.pow(10, getTokenDecimals(exec.source_token))).toString();\n\n    const quoteParams = [\n      'fromChain=' + sourceChainId,\n      'toChain=' + destChainId,\n      'fromToken=' + encodeURIComponent(fromToken),\n      'toToken=' + encodeURIComponent(toToken),\n      'fromAmount=' + fromAmount,\n      'fromAddress=' + encodeURIComponent($env.TREASURY_ADDRESS || '0x0000000000000000000000000000000000000000'),\n      'integrator=' + encodeURIComponent($env.LIFI_INTEGRATOR_ID || 'treasury-ops-bot'),\n    ].join('&');\n\n    const quoteResponse = await fetch('https://li.quest/v1/quote?' + quoteParams);\n    const quoteData = await quoteResponse.json();\n\n    if (quoteData.message || quoteData.error) {\n      throw new Error(quoteData.message || quoteData.error?.message || 'LI.FI quote failed');\n    }\n\n    quote = {\n      provider: 'lifi',\n      fromAmount: quoteData.estimate?.fromAmount,\n      toAmount: quoteData.estimate?.toAmount,\n      toAmountMin: quoteData.estimate?.toAmountMin,\n      executionDuration: quoteData.estimate?.executionDuration,\n      tool: quoteData.tool,\n      steps: quoteData.includedSteps?.length || 1,\n    };\n\n    if (executionMode === 'mock') {\n      mocked = true;\n      txHash = `0xmock_lifi_${Date.now().toString(16)}_${Math.random().toString(16).slice(2, 10)}`;\n    } else {\n      // Live mode: Execute LI.FI transaction with ERC-20 approval\n      const ethers = require('ethers');\n      const treasuryKey = $env.TREASURY_PRIVATE_KEY;\n      if (!treasuryKey) throw new Error('TREASURY_PRIVATE_KEY required for live execution');\n\n      const rpcUrls = { 8453: $env.RPC_BASE || 'https://mainnet.base.org', 42161: $env.RPC_ARBITRUM || 'https://arb1.arbitrum.io/rpc', 1: 'https://eth.llamarpc.com' };\n      const provider = new ethers.JsonRpcProvider(rpcUrls[sourceChainId]);\n      const wallet = new ethers.Wallet(treasuryKey, provider);\n\n      if (!quoteData.transactionRequest) throw new Error('LI.FI quote missing transactionRequest');\n      const txReq = quoteData.transactionRequest;\n\n      // Validate calldata\n      if (!txReq.data || txReq.data === '0x' || txReq.data.length < 10) {\n        throw new Error('LI.FI transactionRequest has invalid data: ' + (txReq.data || 'undefined'));\n      }\n\n      // ERC-20 approval (skip for native ETH)\n      const sourceTokenAddr = getTokenAddress(exec.source_token, sourceChainId);\n      const isNativeToken = sourceTokenAddr === '0x0000000000000000000000000000000000000000' ||\n                            exec.source_token.toUpperCase() === 'ETH';\n\n      if (!isNativeToken) {\n        const erc20Abi = [\n          'function allowance(address owner, address spender) view returns (uint256)',\n          'function approve(address spender, uint256 amount) returns (bool)'\n        ];\n        const tokenContract = new ethers.Contract(sourceTokenAddr, erc20Abi, wallet);\n        const currentAllowance = await tokenContract.allowance(wallet.address, txReq.to);\n        const requiredAmount = BigInt(fromAmount);\n\n        if (currentAllowance < requiredAmount) {\n          const approveTx = await tokenContract.approve(txReq.to, ethers.MaxUint256);\n          await approveTx.wait();\n          quote.approvalTxHash = approveTx.hash;\n        }\n      }\n\n      // Submit swap transaction\n      const tx = await wallet.sendTransaction({\n        to: txReq.to,\n        data: txReq.data,\n        value: txReq.value ? BigInt(txReq.value) : 0n,\n        gasLimit: txReq.gasLimit ? BigInt(txReq.gasLimit) : undefined,\n      });\n      const receipt = await tx.wait();\n      txHash = receipt.hash;\n    }\n\n  } else if (route === 'gateway' || route === 'circle') {\n    // Circle Gateway for USDC-only cross-chain transfers\n    if (executionMode === 'mock') {\n      mocked = true;\n      txHash = `0xmock_gateway_${Date.now().toString(16)}_${Math.random().toString(16).slice(2, 10)}`;\n      quote = {\n        provider: 'circle_gateway',\n        fromAmount: exec.amount,\n        toAmount: exec.amount,  // 1:1 for USDC transfers\n        fee: '0',\n        estimatedTime: '<500ms',\n      };\n    } else {\n      // Live mode: Gateway mint for USDC cross-chain transfer\n      const ethers = require('ethers');\n      const treasuryKey = $env.TREASURY_PRIVATE_KEY;\n      if (!treasuryKey) throw new Error('TREASURY_PRIVATE_KEY required for live execution');\n\n      const rpcUrls = { 8453: $env.RPC_BASE || 'https://mainnet.base.org', 42161: $env.RPC_ARBITRUM || 'https://arb1.arbitrum.io/rpc', 1: 'https://eth.llamarpc.com' };\n      const destProvider = new ethers.JsonRpcProvider(rpcUrls[destChainId]);\n      const destWallet = new ethers.Wallet(treasuryKey, destProvider);\n      const sourceProvider = new ethers.JsonRpcProvider(rpcUrls[sourceChainId]);\n      const sourceWalletForSign = new ethers.Wallet(treasuryKey, sourceProvider);\n\n      const gatewayWallet = '0x77777777Dcc4d5A8B6E418Fd04D8997ef11000eE';\n      const gatewayMinter = '0x2222222d7164433c4C09B0b0D809a9b52C04C205';\n      const circleDomains = { 1: 0, 42161: 3, 8453: 6 };\n      const addrToBytes32 = (a) => '0x' + a.replace('0x','').toLowerCase().padStart(64,'0');\n      const salt = '0x' + [...Array(32)].map(() => Math.floor(Math.random()*256).toString(16).padStart(2,'0')).join('');\n\n      const sourceUsdc = getTokenAddress('USDC', sourceChainId);\n      const destUsdc = getTokenAddress('USDC', destChainId);\n\n      const domain = { name: 'GatewayWallet', version: '1' };\n      const types = { TransferSpec: [ { name:'version',type:'uint8' }, { name:'sourceDomain',type:'uint32' }, { name:'destinationDomain',type:'uint32' }, { name:'sourceContract',type:'bytes32' }, { name:'destinationContract',type:'bytes32' }, { name:'sourceToken',type:'bytes32' }, { name:'destinationToken',type:'bytes32' }, { name:'sourceDepositor',type:'bytes32' }, { name:'destinationRecipient',type:'bytes32' }, { name:'sourceSigner',type:'bytes32' }, { name:'destinationCaller',type:'bytes32' }, { name:'value',type:'uint256' }, { name:'salt',type:'bytes32' }, { name:'hookData',type:'bytes' } ] };\n      const transferSpec = {\n        version: 1,\n        sourceDomain: circleDomains[sourceChainId],\n        destinationDomain: circleDomains[destChainId],\n        sourceContract: addrToBytes32(gatewayWallet),\n        destinationContract: addrToBytes32(gatewayWallet),\n        sourceToken: addrToBytes32(sourceUsdc),\n        destinationToken: addrToBytes32(destUsdc),\n        sourceDepositor: addrToBytes32(sourceWalletForSign.address),\n        destinationRecipient: addrToBytes32(destWallet.address),\n        sourceSigner: addrToBytes32(sourceWalletForSign.address),\n        destinationCaller: addrToBytes32('0x0000000000000000000000000000000000000000'),\n        value: ethers.parseUnits(exec.amount, 6),\n        salt, hookData: '0x'\n      };\n\n      const signature = await sourceWalletForSign.signTypedData(domain, types, transferSpec);\n\n      const circleUrl = $env.CIRCLE_GATEWAY_URL || 'https://gateway-api.circle.com';\n      const circleKey = $env.CIRCLE_API_KEY;\n      const transferResp = await fetch(`${circleUrl}/v1/transfer`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json', ...(circleKey ? { 'Authorization': `Bearer ${circleKey}` } : {}) },\n        body: JSON.stringify({ transferSpec: { ...transferSpec, value: transferSpec.value.toString() }, signature })\n      });\n      const transferData = await transferResp.json();\n      if (!transferResp.ok) throw new Error('Circle API: ' + JSON.stringify(transferData));\n\n      // Poll for attestation\n      let attestation = null;\n      for (let i = 0; i < 60; i++) {\n        const pollResp = await fetch(`${circleUrl}/v1/transfer/${transferData.transferId}`, {\n          headers: circleKey ? { 'Authorization': `Bearer ${circleKey}` } : {}\n        });\n        const pollData = await pollResp.json();\n        if (pollData.attestation && pollData.signature) { attestation = pollData; break; }\n        if (pollData.status === 'failed') throw new Error('Transfer failed: ' + (pollData.error || 'unknown'));\n        await new Promise(r => setTimeout(r, 2000));\n      }\n      if (!attestation) throw new Error('Attestation polling timed out');\n\n      // Call gatewayMint on destination chain\n      const minterAbi = ['function gatewayMint(bytes,bytes)'];\n      const minter = new ethers.Contract(gatewayMinter, minterAbi, destWallet);\n      const tx = await minter.gatewayMint(attestation.attestation, attestation.signature);\n      const receipt = await tx.wait();\n      txHash = receipt.hash;\n\n      quote = {\n        provider: 'circle_gateway',\n        fromAmount: exec.amount,\n        toAmount: exec.amount,\n        fee: '0',\n        estimatedTime: '<500ms',\n      };\n    }\n  } else {\n    throw new Error(`Unknown route: ${route}`);\n  }\n\n} catch (e) {\n  error = e.message;\n}\n\nreturn [{\n  json: {\n    executionId: data.executionId,\n    success: !error,\n    txHash,\n    error,\n    route,\n    mocked,\n    quote,\n    executionMode,\n  }\n}];"
      },
      "id": "execute-swap",
      "name": "Execute Swap",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1100,
        400
      ]
    },
    {
      "parameters": {
        "method": "PATCH",
        "url": "={{ $env.APPWRITE_ENDPOINT }}/databases/{{ $env.APPWRITE_DATABASE_ID || 'treasury' }}/collections/executions/documents/{{ $json.executionId }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Appwrite-Project",
              "value": "={{ $env.APPWRITE_PROJECT_ID }}"
            },
            {
              "name": "X-Appwrite-Key",
              "value": "={{ $env.APPWRITE_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"data\": {\n    \"status\": \"{{ $json.success ? 'completed' : 'failed' }}\",\n    \"tx_hash\": \"{{ $json.txHash || '' }}\",\n    \"error\": \"{{ $json.error || '' }}\",\n    \"completed_at\": \"{{ $now.toISO() }}\"\n  }\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "update-status-appwrite",
      "name": "Update Status in Appwrite",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [
        1320,
        400
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Pass through execution data from Execute Swap for downstream nodes\nconst data = $('Execute Swap').first().json;\n\nreturn [{\n  json: {\n    executionId: data.executionId,\n    success: data.success,\n    txHash: data.txHash,\n    error: data.error,\n    mocked: data.mocked,\n    route: data.route,\n    executionMode: data.executionMode,\n    quote: data.quote,\n  }\n}];"
      },
      "id": "passthrough-status",
      "name": "Passthrough Status",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1540,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_REPORTS }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"embeds\": [{\n    \"title\": \"{{ $json.success ? 'Swap Executed' : 'Swap Failed' }}\",\n    \"description\": \"{{ $json.mocked ? '(MOCK MODE - No real transaction)' : '' }}\",\n    \"color\": {{ $json.success ? 5763719 : 15158332 }},\n    \"fields\": [\n      {\n        \"name\": \"Execution ID\",\n        \"value\": \"`{{ $json.executionId }}`\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Route\",\n        \"value\": \"{{ $json.route }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Mode\",\n        \"value\": \"{{ $json.executionMode ? $json.executionMode.toUpperCase() : 'MOCK' }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"{{ $json.success ? 'Transaction Hash' : 'Error' }}\",\n        \"value\": \"{{ $json.success ? '`' + $json.txHash + '`' : $json.error }}\"\n      }\n    ],\n    \"footer\": {\n      \"text\": \"PigAiBank - Swap Executor\"\n    },\n    \"timestamp\": \"{{ $now.toISO() }}\"\n  }]\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "discord-result",
      "name": "Discord Result",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [
        1760,
        300
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify({ success: $('Passthrough Status').first().json.success, executionId: $('Passthrough Status').first().json.executionId, txHash: $('Passthrough Status').first().json.txHash || null, error: $('Passthrough Status').first().json.error || null, mocked: $('Passthrough Status').first().json.mocked || false, route: $('Passthrough Status').first().json.route, executionMode: $('Passthrough Status').first().json.executionMode }) }}"
      },
      "id": "respond-confirm",
      "name": "Respond Confirm",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1760,
        500
      ]
    }
  ],
  "connections": {
    "Swap Request Webhook": {
      "main": [
        [
          {
            "node": "Validate Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Request": {
      "main": [
        [
          {
            "node": "Prepare Execution Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Execution Data": {
      "main": [
        [
          {
            "node": "Save to Appwrite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to Appwrite": {
      "main": [
        [
          {
            "node": "Extract Execution ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Execution ID": {
      "main": [
        [
          {
            "node": "Notify Discord",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Notify Discord": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Confirm Swap Webhook": {
      "main": [
        [
          {
            "node": "Parse Confirm Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Confirm Request": {
      "main": [
        [
          {
            "node": "Cancelled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cancelled?": {
      "main": [
        [
          {
            "node": "Cancel in Appwrite",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch Execution from Appwrite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cancel in Appwrite": {
      "main": [
        [
          {
            "node": "Format Cancel Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Cancel Response": {
      "main": [
        [
          {
            "node": "Respond Cancel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Execution from Appwrite": {
      "main": [
        [
          {
            "node": "Merge Confirm Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Confirm Data": {
      "main": [
        [
          {
            "node": "Execute Swap",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute Swap": {
      "main": [
        [
          {
            "node": "Update Status in Appwrite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Status in Appwrite": {
      "main": [
        [
          {
            "node": "Passthrough Status",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Passthrough Status": {
      "main": [
        [
          {
            "node": "Discord Result",
            "type": "main",
            "index": 0
          },
          {
            "node": "Respond Confirm",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "pinData": {}
}
