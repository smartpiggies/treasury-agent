{
  "name": "Swap Executor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "swap-executor",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook",
      "name": "Swap Request Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 0],
      "webhookId": "swap-executor",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Validate swap request, resolve ENS names, and determine routing\nconst items = $input.all();\nconst body = items[0]?.json?.body || {};\n\nconst required = ['sourceChain', 'destChain', 'sourceToken', 'destToken', 'amount'];\nconst missing = required.filter(f => !body[f]);\n\nif (missing.length > 0) {\n  throw new Error(`Missing required fields: ${missing.join(', ')}`);\n}\n\nconst amount = parseFloat(body.amount);\nif (isNaN(amount) || amount <= 0) {\n  throw new Error('Invalid amount');\n}\n\n// ENS Resolution helper\nconst resolveENS = async (nameOrAddress) => {\n  if (!nameOrAddress) return null;\n  \n  // Already an address\n  if (nameOrAddress.startsWith('0x') && nameOrAddress.length === 42) {\n    return { address: nameOrAddress, ensName: null, resolved: false };\n  }\n  \n  // ENS name - resolve it\n  if (nameOrAddress.endsWith('.eth')) {\n    try {\n      // Use ENS subgraph via The Graph decentralized network\n      const ensSubgraphId = '5XqPmWe6gjyrJtFn9cLy237i4cWw2j9HcUNNo1dFmrpz';\n      const graphApiKey = $env.GRAPH_API_KEY;\n      const ensEndpoint = graphApiKey \n        ? `https://gateway.thegraph.com/api/${graphApiKey}/subgraphs/id/${ensSubgraphId}`\n        : 'https://api.thegraph.com/subgraphs/name/ensdomains/ens'; // Fallback\n      const response = await fetch(ensEndpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          query: `{ domains(where: { name: \"${nameOrAddress}\" }) { resolvedAddress { id } } }`\n        })\n      });\n      const data = await response.json();\n      const address = data?.data?.domains?.[0]?.resolvedAddress?.id;\n      if (address) {\n        return { address, ensName: nameOrAddress, resolved: true };\n      }\n    } catch (e) {\n      // Fallback: try mainnet RPC\n    }\n    throw new Error(`Could not resolve ENS name: ${nameOrAddress}`);\n  }\n  \n  throw new Error(`Invalid address or ENS name: ${nameOrAddress}`);\n};\n\n// Resolve recipient if provided (supports ENS names like \"vitalik.eth\")\nlet recipient = null;\nlet recipientENS = null;\nif (body.recipient) {\n  const resolved = await resolveENS(body.recipient);\n  recipient = resolved.address;\n  recipientENS = resolved.ensName;\n}\n\n// Normalize chain names\nconst normalizeChain = (chain) => chain.toLowerCase().replace(/[_\\-\\s]/g, '');\nconst sourceChain = normalizeChain(body.sourceChain);\nconst destChain = normalizeChain(body.destChain);\n\n// Chain ID mapping\nconst chainIds = {\n  'base': 8453,\n  'arbitrum': 42161,\n  'optimism': 10,\n  'ethereum': 1,\n  'polygon': 137,\n  // Testnets\n  'basesepolia': 84532,\n  'arbitrumsepolia': 421614,\n  'sepolia': 11155111,\n};\n\nconst sourceChainId = chainIds[sourceChain];\nconst destChainId = chainIds[destChain];\n\nif (!sourceChainId || !destChainId) {\n  throw new Error(`Unknown chain: ${!sourceChainId ? body.sourceChain : body.destChain}`);\n}\n\n// Determine if testnet\nconst isTestnet = [84532, 421614, 11155111].includes(sourceChainId) || \n                  [84532, 421614, 11155111].includes(destChainId);\n\n// Determine routing\nconst isCrossChain = sourceChainId !== destChainId;\nconst isUsdcOnly = body.sourceToken.toUpperCase() === 'USDC' && body.destToken.toUpperCase() === 'USDC';\n\nlet route = 'uniswap'; // Default: same-chain swap\nif (isCrossChain) {\n  if (isUsdcOnly) {\n    route = 'gateway'; // Circle Gateway for USDC-only cross-chain\n  } else {\n    route = 'lifi'; // LI.FI for cross-chain with swap\n  }\n}\n\n// Get execution mode\nconst executionMode = $env.EXECUTION_MODE || 'mock';\n\nreturn [{\n  json: {\n    ...body,\n    amount,\n    sourceChain,\n    destChain,\n    sourceChainId,\n    destChainId,\n    route,\n    isCrossChain,\n    isTestnet,\n    isUsdcOnly,\n    executionMode,\n    recipient,\n    recipientENS,\n    timestamp: new Date().toISOString(),\n  }\n}];"
      },
      "id": "validate",
      "name": "Validate Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 0]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Create execution record in Appwrite\nconst items = $input.all();\nconst data = items[0]?.json || {};\n\nconst endpoint = $env.APPWRITE_ENDPOINT;\nconst projectId = $env.APPWRITE_PROJECT_ID;\nconst apiKey = $env.APPWRITE_API_KEY;\nconst databaseId = $env.APPWRITE_DATABASE_ID || 'treasury';\n\nif (!endpoint || !apiKey) {\n  return [{ json: { ...data, executionId: 'local-' + Date.now() } }];\n}\n\ntry {\n  const response = await fetch(\n    `${endpoint}/databases/${databaseId}/collections/executions/documents`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n      body: JSON.stringify({\n        documentId: 'unique()',\n        data: {\n          timestamp: data.timestamp,\n          type: 'swap',\n          source_chain: data.sourceChain,\n          dest_chain: data.destChain,\n          source_token: data.sourceToken,\n          dest_token: data.destToken,\n          amount: String(data.amount),\n          status: 'pending',\n          route: data.route,\n          reason: data.reason || '',\n          requester: 'webhook',\n          execution_mode: data.executionMode,\n          is_testnet: data.isTestnet,\n          recipient: data.recipient || '',\n          recipient_ens: data.recipientENS || '',\n        },\n      }),\n    }\n  );\n\n  const result = await response.json();\n\n  return [{\n    json: {\n      ...data,\n      executionId: result.$id || 'local-' + Date.now(),\n    }\n  }];\n} catch (error) {\n  return [{ json: { ...data, executionId: 'local-' + Date.now() } }];\n}"
      },
      "id": "create-execution",
      "name": "Create Execution Record",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 0]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_REPORTS }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"embeds\": [{\n    \"title\": \"Swap Request Received\",\n    \"description\": \"A new swap request is pending confirmation.{{ $json.recipientENS ? ' (ENS: ' + $json.recipientENS + ' resolved!)' : '' }}\",\n    \"color\": 3447003,\n    \"fields\": [\n      {\n        \"name\": \"From\",\n        \"value\": \"{{ $json.amount }} {{ $json.sourceToken }} on {{ $json.sourceChain }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"To\",\n        \"value\": \"{{ $json.destToken }} on {{ $json.destChain }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Route\",\n        \"value\": \"{{ $json.route }}{{ $json.isCrossChain ? ' (cross-chain)' : ' (same-chain)' }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Mode\",\n        \"value\": \"{{ $json.executionMode.toUpperCase() }}{{ $json.isTestnet ? ' (testnet)' : '' }}\",\n        \"inline\": true\n      },\n      {{ $json.recipient ? '{\"name\": \"Recipient\", \"value\": \"' + ($json.recipientENS ? $json.recipientENS + ' â†’ ' : '') + '`' + $json.recipient.substring(0,10) + '...`\", \"inline\": true},' : '' }}\n      {\n        \"name\": \"Execution ID\",\n        \"value\": \"`{{ $json.executionId }}`\"\n      }\n    ],\n    \"footer\": {\n      \"text\": \"POST /webhook/swap-confirm to execute or cancel\"\n    },\n    \"timestamp\": \"{{ $json.timestamp }}\"\n  }]\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "notify-discord",
      "name": "Notify Discord",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [660, 0],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"executionId\": \"{{ $('Create Execution Record').first().json.executionId }}\",\n  \"status\": \"pending\",\n  \"message\": \"Swap request created. POST to /webhook/swap-confirm to execute.\",\n  \"route\": \"{{ $('Create Execution Record').first().json.route }}\",\n  \"executionMode\": \"{{ $('Create Execution Record').first().json.executionMode }}\",\n  \"isTestnet\": {{ $('Create Execution Record').first().json.isTestnet ? 'true' : 'false' }}\n}"
      },
      "id": "respond",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [880, 0]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "swap-confirm",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "confirm-webhook",
      "name": "Confirm Swap Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 300],
      "webhookId": "swap-confirm",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Get execution details and prepare for swap\nconst items = $input.all();\nconst body = items[0]?.json?.body || {};\nconst { executionId, action } = body;\n\nif (!executionId) {\n  throw new Error('executionId is required');\n}\n\nif (action === 'cancel') {\n  return [{ json: { executionId, cancelled: true } }];\n}\n\n// Fetch execution from Appwrite\nconst endpoint = $env.APPWRITE_ENDPOINT;\nconst projectId = $env.APPWRITE_PROJECT_ID;\nconst apiKey = $env.APPWRITE_API_KEY;\nconst databaseId = $env.APPWRITE_DATABASE_ID || 'treasury';\n\nif (!endpoint || !apiKey) {\n  throw new Error('Appwrite not configured');\n}\n\nconst response = await fetch(\n  `${endpoint}/databases/${databaseId}/collections/executions/documents/${executionId}`,\n  {\n    headers: {\n      'X-Appwrite-Project': projectId,\n      'X-Appwrite-Key': apiKey,\n    },\n  }\n);\n\nif (!response.ok) {\n  throw new Error(`Execution not found: ${executionId}`);\n}\n\nconst execution = await response.json();\n\nreturn [{\n  json: {\n    executionId,\n    cancelled: false,\n    execution,\n    executionMode: $env.EXECUTION_MODE || 'mock',\n  }\n}];"
      },
      "id": "get-execution",
      "name": "Get Execution Details",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "condition-cancelled",
              "leftValue": "={{ $json.cancelled }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-cancelled",
      "name": "Cancelled?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [440, 300]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Execute swap with smart routing: Uniswap (same-chain), LI.FI (cross-chain), Gateway (USDC)\nconst items = $input.all();\nconst data = items[0]?.json || {};\nconst exec = data.execution || {};\nconst executionMode = data.executionMode || 'mock';\n\nconst route = exec.route;\nlet txHash = null;\nlet error = null;\nlet mocked = false;\nlet quote = null;\n\n// Chain ID mapping\nconst chainIds = {\n  'base': 8453,\n  'arbitrum': 42161,\n  'optimism': 10,\n  'ethereum': 1,\n  'polygon': 137,\n};\n\n// Uniswap v3 subgraph IDs per chain (The Graph decentralized network)\nconst uniswapSubgraphs = {\n  8453: 'GqzP4Xaehti8KSfQmv3ZctFSjnSUYZ4En5NRsiTbvZpz',  // Base\n  42161: '5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV', // Arbitrum\n  10: 'Cghf4LfVqPiFw6fp6Y5X5Ubc8UpmUhSfJL82zwiBFLaj',   // Optimism\n  1: '5zvR82QoaXYFyDEKLZ9t6v9adgnptxYpKpSbxtgVENFV',    // Ethereum (using Arb as fallback)\n};\n\nconst sourceChainId = chainIds[exec.source_chain] || 8453;\nconst destChainId = chainIds[exec.dest_chain] || 8453;\n\n// Token addresses (mainnet)\nconst tokenAddresses = {\n  'USDC': {\n    8453: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\n    42161: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',\n    10: '0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85',\n    1: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n  },\n  'WETH': {\n    8453: '0x4200000000000000000000000000000000000006',\n    42161: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',\n    10: '0x4200000000000000000000000000000000000006',\n    1: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n  },\n  'ETH': {\n    8453: '0x4200000000000000000000000000000000000006',\n    42161: '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1',\n    10: '0x4200000000000000000000000000000000000006',\n    1: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n  },\n};\n\nconst getTokenAddress = (symbol, chainId) => {\n  const upper = symbol?.toUpperCase();\n  return tokenAddresses[upper]?.[chainId] || symbol;\n};\n\nconst getTokenDecimals = (symbol) => {\n  return symbol?.toUpperCase() === 'USDC' ? 6 : 18;\n};\n\ntry {\n  if (route === 'uniswap') {\n    // DIRECT UNISWAP INTEGRATION - Same-chain swaps via Uniswap v3\n    const graphApiKey = $env.GRAPH_API_KEY;\n    const subgraphId = uniswapSubgraphs[sourceChainId];\n    \n    if (!graphApiKey) {\n      throw new Error('GRAPH_API_KEY required for Uniswap integration');\n    }\n    \n    const fromToken = getTokenAddress(exec.source_token, sourceChainId).toLowerCase();\n    const toToken = getTokenAddress(exec.dest_token, sourceChainId).toLowerCase();\n    const fromDecimals = getTokenDecimals(exec.source_token);\n    const toDecimals = getTokenDecimals(exec.dest_token);\n    const inputAmount = parseFloat(exec.amount);\n    \n    // Query Uniswap v3 subgraph for pool data and price\n    const poolQuery = `{\n      pools(\n        first: 1,\n        where: {\n          or: [\n            { token0_: { id: \"${fromToken}\" }, token1_: { id: \"${toToken}\" } },\n            { token0_: { id: \"${toToken}\" }, token1_: { id: \"${fromToken}\" } }\n          ]\n        },\n        orderBy: totalValueLockedUSD,\n        orderDirection: desc\n      ) {\n        id\n        token0 { id symbol decimals }\n        token1 { id symbol decimals }\n        token0Price\n        token1Price\n        feeTier\n        liquidity\n        totalValueLockedUSD\n      }\n    }`;\n    \n    const graphResponse = await fetch(\n      `https://gateway.thegraph.com/api/${graphApiKey}/subgraphs/id/${subgraphId}`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ query: poolQuery })\n      }\n    );\n    \n    const graphData = await graphResponse.json();\n    const pool = graphData?.data?.pools?.[0];\n    \n    if (!pool) {\n      throw new Error(`No Uniswap pool found for ${exec.source_token}/${exec.dest_token} on chain ${sourceChainId}`);\n    }\n    \n    // Calculate output amount based on pool price\n    const isToken0Input = pool.token0.id.toLowerCase() === fromToken;\n    const price = isToken0Input ? parseFloat(pool.token1Price) : parseFloat(pool.token0Price);\n    const outputAmount = inputAmount * price;\n    \n    // Apply slippage (0.5%)\n    const slippage = 0.005;\n    const minOutput = outputAmount * (1 - slippage);\n    \n    quote = {\n      provider: 'uniswap_v3_direct',\n      pool: pool.id,\n      feeTier: pool.feeTier,\n      fromToken: exec.source_token,\n      toToken: exec.dest_token,\n      fromAmount: inputAmount.toString(),\n      fromAmountWei: (inputAmount * Math.pow(10, fromDecimals)).toString(),\n      toAmount: outputAmount.toFixed(toDecimals === 6 ? 6 : 8),\n      toAmountMin: minOutput.toFixed(toDecimals === 6 ? 6 : 8),\n      price: price.toString(),\n      priceImpact: 'calculated_from_pool',\n      liquidityUSD: pool.totalValueLockedUSD,\n      chain: exec.source_chain,\n      chainId: sourceChainId,\n    };\n    \n    if (executionMode === 'mock') {\n      mocked = true;\n      txHash = `0xmock_uniswap_${sourceChainId}_${Date.now().toString(16)}_${Math.random().toString(16).slice(2, 10)}`;\n    } else {\n      // Live mode: Build Universal Router transaction\n      // This would require encoding the swap call for Universal Router contract\n      throw new Error('Live Uniswap execution requires Universal Router integration. Set EXECUTION_MODE=mock for demo.');\n    }\n    \n  } else if (route === 'lifi') {\n    // LI.FI for cross-chain swaps\n    const fromToken = getTokenAddress(exec.source_token, sourceChainId);\n    const toToken = getTokenAddress(exec.dest_token, destChainId);\n    const fromAmount = (parseFloat(exec.amount) * Math.pow(10, getTokenDecimals(exec.source_token))).toString();\n\n    const quoteParams = new URLSearchParams({\n      fromChain: sourceChainId.toString(),\n      toChain: destChainId.toString(),\n      fromToken: fromToken,\n      toToken: toToken,\n      fromAmount: fromAmount,\n      fromAddress: $env.TREASURY_ADDRESS || '0x0000000000000000000000000000000000000000',\n      integrator: $env.LIFI_INTEGRATOR_ID || 'treasury-ops-bot',\n    });\n\n    const quoteResponse = await fetch(`https://li.quest/v1/quote?${quoteParams}`);\n    const quoteData = await quoteResponse.json();\n\n    if (quoteData.message || quoteData.error) {\n      throw new Error(quoteData.message || quoteData.error?.message || 'LI.FI quote failed');\n    }\n\n    quote = {\n      provider: 'lifi',\n      fromAmount: quoteData.estimate?.fromAmount,\n      toAmount: quoteData.estimate?.toAmount,\n      toAmountMin: quoteData.estimate?.toAmountMin,\n      executionDuration: quoteData.estimate?.executionDuration,\n      tool: quoteData.tool,\n      steps: quoteData.includedSteps?.length || 1,\n    };\n\n    if (executionMode === 'mock') {\n      mocked = true;\n      txHash = `0xmock_lifi_${Date.now().toString(16)}_${Math.random().toString(16).slice(2, 10)}`;\n    } else {\n      throw new Error('Live LI.FI execution requires transaction signing. Set EXECUTION_MODE=mock for demo.');\n    }\n\n  } else if (route === 'gateway') {\n    // Circle Gateway for USDC-only cross-chain transfers\n    if (executionMode === 'mock') {\n      mocked = true;\n      txHash = `0xmock_gateway_${Date.now().toString(16)}_${Math.random().toString(16).slice(2, 10)}`;\n      quote = {\n        provider: 'circle_gateway',\n        fromAmount: exec.amount,\n        toAmount: exec.amount,  // 1:1 for USDC transfers\n        fee: '0',\n        estimatedTime: '<500ms',\n      };\n    } else {\n      throw new Error('Live Circle Gateway execution requires EIP-712 signing. Set EXECUTION_MODE=mock for demo.');\n    }\n  } else {\n    throw new Error(`Unknown route: ${route}`);\n  }\n\n} catch (e) {\n  error = e.message;\n}\n\nreturn [{\n  json: {\n    executionId: data.executionId,\n    success: !error,\n    txHash,\n    error,\n    route,\n    mocked,\n    quote,\n    executionMode,\n  }\n}];"
      },
      "id": "execute-swap",
      "name": "Execute Swap",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Update execution status in Appwrite\nconst items = $input.all();\nconst data = items[0]?.json || {};\n\nconst endpoint = $env.APPWRITE_ENDPOINT;\nconst projectId = $env.APPWRITE_PROJECT_ID;\nconst apiKey = $env.APPWRITE_API_KEY;\nconst databaseId = $env.APPWRITE_DATABASE_ID || 'treasury';\n\nif (!endpoint || !apiKey || !data.executionId) {\n  return [{ json: data }];\n}\n\ntry {\n  await fetch(\n    `${endpoint}/databases/${databaseId}/collections/executions/documents/${data.executionId}`,\n    {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n      body: JSON.stringify({\n        data: {\n          status: data.success ? 'completed' : 'failed',\n          tx_hash: data.txHash || '',\n          error: data.error || '',\n          mocked: data.mocked || false,\n          completed_at: new Date().toISOString(),\n        },\n      }),\n    }\n  );\n} catch (error) {\n  // Log but don't fail\n}\n\nreturn [{ json: data }];"
      },
      "id": "update-status",
      "name": "Update Execution Status",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_REPORTS }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"embeds\": [{\n    \"title\": \"{{ $json.success ? 'Swap Executed' : 'Swap Failed' }}\",\n    \"description\": \"{{ $json.mocked ? '(MOCK MODE - No real transaction)' : '' }}\",\n    \"color\": {{ $json.success ? 5763719 : 15158332 }},\n    \"fields\": [\n      {\n        \"name\": \"Execution ID\",\n        \"value\": \"`{{ $json.executionId }}`\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Route\",\n        \"value\": \"{{ $json.route }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Mode\",\n        \"value\": \"{{ $json.executionMode ? $json.executionMode.toUpperCase() : 'MOCK' }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"{{ $json.success ? 'Transaction Hash' : 'Error' }}\",\n        \"value\": \"{{ $json.success ? '`' + $json.txHash + '`' : $json.error }}\"\n      }\n    ],\n    \"footer\": {\n      \"text\": \"PigAiBank - Swap Executor\"\n    },\n    \"timestamp\": \"{{ $now.toISO() }}\"\n  }]\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "discord-result",
      "name": "Discord Result",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [1100, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": {{ $json.success }},\n  \"executionId\": \"{{ $json.executionId }}\",\n  \"txHash\": {{ $json.txHash ? '\"' + $json.txHash + '\"' : 'null' }},\n  \"error\": {{ $json.error ? '\"' + $json.error + '\"' : 'null' }},\n  \"mocked\": {{ $json.mocked }},\n  \"route\": \"{{ $json.route }}\",\n  \"executionMode\": \"{{ $json.executionMode }}\"\n}"
      },
      "id": "respond-confirm",
      "name": "Respond Confirm",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1320, 400]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Mark as cancelled in Appwrite\nconst items = $input.all();\nconst data = items[0]?.json || {};\n\nconst endpoint = $env.APPWRITE_ENDPOINT;\nconst projectId = $env.APPWRITE_PROJECT_ID;\nconst apiKey = $env.APPWRITE_API_KEY;\nconst databaseId = $env.APPWRITE_DATABASE_ID || 'treasury';\n\nif (endpoint && apiKey && data.executionId) {\n  try {\n    await fetch(\n      `${endpoint}/databases/${databaseId}/collections/executions/documents/${data.executionId}`,\n      {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Appwrite-Project': projectId,\n          'X-Appwrite-Key': apiKey,\n        },\n        body: JSON.stringify({\n          data: {\n            status: 'cancelled',\n            completed_at: new Date().toISOString(),\n          },\n        }),\n      }\n    );\n  } catch (error) {\n    // Log but don't fail\n  }\n}\n\nreturn [{ json: { cancelled: true, executionId: data.executionId } }];"
      },
      "id": "cancel-execution",
      "name": "Cancel Execution",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 200]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"executionId\": \"{{ $json.executionId }}\",\n  \"status\": \"cancelled\"\n}"
      },
      "id": "respond-cancel",
      "name": "Respond Cancel",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [880, 200]
    }
  ],
  "connections": {
    "Swap Request Webhook": {
      "main": [
        [{ "node": "Validate Request", "type": "main", "index": 0 }]
      ]
    },
    "Validate Request": {
      "main": [
        [{ "node": "Create Execution Record", "type": "main", "index": 0 }]
      ]
    },
    "Create Execution Record": {
      "main": [
        [{ "node": "Notify Discord", "type": "main", "index": 0 }]
      ]
    },
    "Notify Discord": {
      "main": [
        [{ "node": "Respond to Webhook", "type": "main", "index": 0 }]
      ]
    },
    "Confirm Swap Webhook": {
      "main": [
        [{ "node": "Get Execution Details", "type": "main", "index": 0 }]
      ]
    },
    "Get Execution Details": {
      "main": [
        [{ "node": "Cancelled?", "type": "main", "index": 0 }]
      ]
    },
    "Cancelled?": {
      "main": [
        [{ "node": "Cancel Execution", "type": "main", "index": 0 }],
        [{ "node": "Execute Swap", "type": "main", "index": 0 }]
      ]
    },
    "Cancel Execution": {
      "main": [
        [{ "node": "Respond Cancel", "type": "main", "index": 0 }]
      ]
    },
    "Execute Swap": {
      "main": [
        [{ "node": "Update Execution Status", "type": "main", "index": 0 }]
      ]
    },
    "Update Execution Status": {
      "main": [
        [
          { "node": "Discord Result", "type": "main", "index": 0 },
          { "node": "Respond Confirm", "type": "main", "index": 0 }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "pinData": {}
}
