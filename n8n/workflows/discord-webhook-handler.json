{
  "name": "Discord Webhook Handler",
  "nodes": [
    {
      "id": "webhook-trigger",
      "name": "Discord Command Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "discord-cmd",
      "parameters": {
        "path": "discord-cmd",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      }
    },
    {
      "id": "parse-intent",
      "name": "Parse Intent",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const content = $input.first().json.body?.content || $input.first().json.content || '';\nconst lowerContent = content.toLowerCase().trim();\nlet intent = 'unknown';\nlet params = {};\n\n// Check for confirm/cancel intent first (highest priority)\nif (/^(confirm|yes|do it|execute|go|proceed)$/i.test(lowerContent)) {\n  intent = 'confirm';\n  params.action = 'confirm';\n} else if (/^(cancel|abort|no|stop|nevermind|never mind)$/i.test(lowerContent)) {\n  intent = 'confirm';\n  params.action = 'cancel';\n// Check for deposit intent\n} else if (lowerContent.includes('deposit')) {\n  intent = 'deposit';\n  // Match patterns like \"deposit $100\", \"deposit 50 USDC\", \"deposit $100 on Base\"\n  const depositMatch = lowerContent.match(/deposit\\s*\\$?(\\d+(?:\\.\\d+)?)(?:\\s+usdc)?(?:\\s+(?:on|to)\\s+(ethereum|arbitrum|base))?/i);\n  if (depositMatch) {\n    params.amount = depositMatch[1];\n    params.chain = depositMatch[2] || 'arbitrum'; // default to Arbitrum\n  }\n} else if (lowerContent.includes('swap') || lowerContent.includes('convert') || lowerContent.includes('exchange')) {\n  intent = 'swap';\n  const swapMatch = lowerContent.match(/(\\d+(?:\\.\\d+)?)\\s*(usdc|eth|usdt)\\s*(?:to|for|into)\\s*(usdc|eth|usdt)/i);\n  if (swapMatch) {\n    params.amount = swapMatch[1];\n    params.fromToken = swapMatch[2].toUpperCase();\n    params.toToken = swapMatch[3].toUpperCase();\n  }\n} else if (lowerContent.includes('send') || lowerContent.includes('transfer')) {\n  intent = 'send';\n  const sendMatch = lowerContent.match(/(\\d+(?:\\.\\d+)?)\\s*(usdc|eth)\\s*(?:to)\\s*([\\w\\.]+)/i);\n  if (sendMatch) {\n    params.amount = sendMatch[1];\n    params.token = sendMatch[2].toUpperCase();\n    params.recipient = sendMatch[3];\n  }\n} else if (lowerContent.includes('balance') || lowerContent.includes('how much')) {\n  intent = 'balance';\n} else if (lowerContent.includes('price') || lowerContent.match(/^(eth|bitcoin|btc)\\s*\\??$/)) {\n  intent = 'price';\n  params.token = lowerContent.includes('btc') || lowerContent.includes('bitcoin') ? 'BTC' : 'ETH';\n} else if (lowerContent.includes('help') || lowerContent === '?') {\n  intent = 'help';\n} else if (lowerContent.match(/^(hi|hello|hey|gm|good morning)/)) {\n  intent = 'greeting';\n}\n\nreturn [{json: {...$input.first().json.body || $input.first().json, intent, params, originalContent: content}}];"
      }
    },
    {
      "id": "route-intent",
      "name": "Route by Intent",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [650, 300],
      "parameters": {
        "rules": {
          "values": [
            {
              "outputKey": "balance",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "balance-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "balance"}]
              }
            },
            {
              "outputKey": "price",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "price-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "price"}]
              }
            },
            {
              "outputKey": "swap",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "swap-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "swap"}]
              }
            },
            {
              "outputKey": "deposit",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "deposit-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "deposit"}]
              }
            },
            {
              "outputKey": "send",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "send-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "send"}]
              }
            },
            {
              "outputKey": "help",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "help-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "help"}]
              }
            },
            {
              "outputKey": "confirm",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "confirm-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "confirm"}]
              }
            }
          ]
        },
        "options": {"fallbackOutput": "extra"}
      }
    },
    {
      "id": "get-circle-balance",
      "name": "Get Gateway Balance",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 100],
      "onError": "continueRegularOutput",
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Fetch Gateway balances from Circle REST API (accurate available balance)\nconst fetch = require('node-fetch');\nconst CIRCLE_GATEWAY_URL = $env.CIRCLE_GATEWAY_URL || 'https://gateway-api.circle.com';\nconst depositor = $env.TREASURY_ADDRESS;\n\nconst sources = [\n  { domain: 0, depositor },\n  { domain: 3, depositor },\n  { domain: 6, depositor },\n];\n\nconst response = await fetch(`${CIRCLE_GATEWAY_URL}/v1/balances`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ token: 'USDC', sources }),\n});\n\nif (!response.ok) {\n  const body = await response.text();\n  throw new Error(`Circle API error ${response.status}: ${body}`);\n}\n\nconst data = await response.json();\nreturn [{ json: { balances: data.balances, token: data.token } }];"
      }
    },
    {
      "id": "format-balance",
      "name": "Format Balance Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 100],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const data = $input.first().json;\nconst author = $node['Parse Intent'].json.author?.displayName || 'there';\n\n// Check for errors\nif (data.error || (data.message && !data.balances)) {\n  return [{json: {reply: `Hey ${author}! Error fetching balance: ${data.message || data.error}`}}];\n}\n\n// Parse Circle Gateway response (new format: balance is string like \"1000.50\")\nconst balances = data.balances || [];\nlet totalUsdc = 0;\nconst chainBalances = [];\nconst domainNames = {0: 'Ethereum', 3: 'Arbitrum', 6: 'Base'};\n\nfor (const bal of balances) {\n  // New API returns 'balance' as formatted string (e.g., \"1000.50\")\n  const amount = parseFloat(bal.balance || bal.amount || '0');\n  totalUsdc += amount;\n  if (amount > 0) {\n    chainBalances.push(`${domainNames[bal.domain] || 'Chain ' + bal.domain}: $${amount.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`);\n  }\n}\n\nconst balanceList = chainBalances.length > 0 \n  ? chainBalances.join('\\n- ') \n  : 'No USDC balances found (deposit USDC to Gateway first)';\n\nconst totalFormatted = totalUsdc.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});\n\nreturn [{json: {reply: `Hey ${author}! Here's your treasury balance:\\n\\n**Total USDC: $${totalFormatted}**\\n- ${balanceList}\\n\\n_Powered by Circle Gateway_`}}];"
      }
    },
    {
      "id": "get-eth-price",
      "name": "Get ETH Price",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 250],
      "onError": "continueRegularOutput",
      "parameters": {
        "method": "POST",
        "url": "=https://gateway.thegraph.com/api/{{ $env.GRAPH_API_KEY }}/subgraphs/id/{{ $env.GRAPH_SUBGRAPH_ARBITRUM }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [{"name": "Content-Type", "value": "application/json"}]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"query\": \"{ bundles(first: 1) { ethPriceUSD } }\"}",
        "options": {"response": {"response": {"neverError": true}}}
      }
    },
    {
      "id": "format-price",
      "name": "Format Price Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 250],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const data = $input.first().json;\nconst ethPrice = parseFloat(data?.data?.bundles?.[0]?.ethPriceUSD || 0);\nif (ethPrice === 0) {\n  return [{json: {reply: 'Error fetching price'}}];\n}\nconst formatted = ethPrice.toLocaleString('en-US', {style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2});\nreturn [{json: {reply: `**ETH Price**: ${formatted}\\n\\n_Data from Uniswap v3 on Arbitrum via The Graph_`}}];"
      }
    },
    {
      "id": "create-swap-quote",
      "name": "Create Swap Quote",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 400],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const fetch = require('node-fetch');\nconst params = $input.first().json.params || {};\nconst author = $input.first().json.author?.displayName || 'there';\n\nif (!params.amount || !params.fromToken || !params.toToken) {\n  return [{json: {reply: `I couldn't parse your swap request. Try: \"swap 100 USDC to ETH\"`}}];\n}\n\n// Determine route (same-chain default for now)\nconst sourceChain = 'arbitrum';\nconst destChain = 'arbitrum';\nlet route = 'uniswap';\nif (params.fromToken === 'USDC' && params.toToken === 'USDC') {\n  route = 'circle';\n}\n\n// Create pending execution in Appwrite\nconst appwriteEndpoint = $env.APPWRITE_ENDPOINT || 'https://aw.smartpiggies.cloud/v1';\nconst dbId = $env.APPWRITE_DATABASE_ID || 'treasury';\nconst projectId = $env.APPWRITE_PROJECT_ID || 'treasury-agent-1';\nconst apiKey = $env.APPWRITE_API_KEY;\n\ntry {\n  const response = await fetch(\n    `${appwriteEndpoint}/databases/${dbId}/collections/executions/documents`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n      body: JSON.stringify({\n        documentId: 'unique()',\n        data: {\n          timestamp: new Date().toISOString(),\n          type: 'swap',\n          source_chain: sourceChain,\n          dest_chain: destChain,\n          source_token: params.fromToken.toUpperCase(),\n          dest_token: params.toToken.toUpperCase(),\n          amount: params.amount.toString(),\n          status: 'pending',\n          route: route,\n          requester: 'discord',\n        },\n      }),\n    }\n  );\n\n  if (!response.ok) {\n    const errBody = await response.text();\n    throw new Error(`Appwrite ${response.status}: ${errBody}`);\n  }\n\n  const doc = await response.json();\n  const executionId = doc.$id;\n\n  const routeLabel = route === 'uniswap' ? 'Uniswap v4 (same-chain)' : route === 'circle' ? 'Circle Gateway' : 'LI.FI';\n\n  return [{json: {reply: `**Swap Quote**\\n\\nFrom: ${params.amount} ${params.fromToken}\\nTo: ${params.toToken}\\nRoute: ${routeLabel}\\nExecution ID: \\`${executionId}\\`\\n\\n_Reply **confirm** to execute or **cancel** to abort._`}}];\n} catch (error) {\n  return [{json: {reply: `**Error creating swap quote**: ${error.message}\\n\\nPlease try again.`}}];\n}"
      }
    },
    {
      "id": "handle-confirm",
      "name": "Handle Confirm/Cancel",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 475],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const fetch = require('node-fetch');\nconst action = $input.first().json.params?.action || 'confirm';\n\nconst appwriteEndpoint = $env.APPWRITE_ENDPOINT || 'https://aw.smartpiggies.cloud/v1';\nconst dbId = $env.APPWRITE_DATABASE_ID || 'treasury';\nconst projectId = $env.APPWRITE_PROJECT_ID || 'treasury-agent-1';\nconst apiKey = $env.APPWRITE_API_KEY;\n\ntry {\n  // Query Appwrite for the latest pending execution (JSON method format)\n  const queries = [\n    JSON.stringify({method: 'equal', attribute: 'status', values: ['pending']}),\n    JSON.stringify({method: 'orderDesc', attribute: '$createdAt'}),\n    JSON.stringify({method: 'limit', values: [1]}),\n  ];\n  const qs = queries.map(q => 'queries[]=' + encodeURIComponent(q)).join('&');\n\n  const listResponse = await fetch(\n    `${appwriteEndpoint}/databases/${dbId}/collections/executions/documents?${qs}`,\n    {\n      headers: {\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n    }\n  );\n\n  if (!listResponse.ok) {\n    const errBody = await listResponse.text();\n    throw new Error(`Appwrite list ${listResponse.status}: ${errBody}`);\n  }\n\n  const listData = await listResponse.json();\n\n  if (!listData.documents || listData.documents.length === 0) {\n    return [{json: {reply: `No pending swap found. Use **swap [amount] [token] to [token]** to create one first.`}}];\n  }\n\n  const pendingExec = listData.documents[0];\n  const executionId = pendingExec.$id;\n\n  if (action === 'cancel') {\n    // Cancel directly via Appwrite PATCH\n    const cancelResponse = await fetch(\n      `${appwriteEndpoint}/databases/${dbId}/collections/executions/documents/${executionId}`,\n      {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Appwrite-Project': projectId,\n          'X-Appwrite-Key': apiKey,\n        },\n        body: JSON.stringify({\n          data: {\n            status: 'cancelled',\n            completed_at: new Date().toISOString(),\n          },\n        }),\n      }\n    );\n\n    if (!cancelResponse.ok) {\n      const errBody = await cancelResponse.text();\n      throw new Error(`Cancel failed ${cancelResponse.status}: ${errBody}`);\n    }\n\n    return [{json: {reply: `**Swap Cancelled**\\n\\nExecution \\`${executionId}\\` has been cancelled.\\n${pendingExec.amount} ${pendingExec.source_token} → ${pendingExec.dest_token} will not be executed.`}}];\n  }\n\n  // Confirm: call the swap-confirm webhook\n  const n8nBaseUrl = 'https://n8n.smartpiggies.cloud';\n  const confirmResponse = await fetch(\n    `${n8nBaseUrl}/webhook/swap-confirm`,\n    {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ executionId, action: 'confirm' }),\n    }\n  );\n\n  const confirmResult = await confirmResponse.json();\n\n  if (confirmResult.success) {\n    const txHash = confirmResult.txHash || confirmResult.tx_hash || 'N/A';\n    return [{json: {reply: `**Swap Executed!**\\n\\nExecution: \\`${executionId}\\`\\n${pendingExec.amount} ${pendingExec.source_token} → ${pendingExec.dest_token}\\nTx: \\`${txHash}\\`\\n\\n_Powered by ${pendingExec.route === 'circle' ? 'Circle Gateway' : pendingExec.route === 'uniswap' ? 'Uniswap v4' : 'LI.FI'}_`}}];\n  } else {\n    const errorMsg = confirmResult.error || confirmResult.message || 'Unknown error';\n    return [{json: {reply: `**Swap Failed**\\n\\nExecution: \\`${executionId}\\`\\nError: ${errorMsg}\\n\\nPlease try again or check the dashboard.`}}];\n  }\n} catch (error) {\n  return [{json: {reply: `**Error**: ${error.message}`}}];\n}"
      }
    },
    {
      "id": "handle-deposit",
      "name": "Handle Deposit",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 550],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const params = $input.first().json.params || {};\nconst author = $input.first().json.author?.displayName || 'there';\nconst executionMode = $env.EXECUTION_MODE || 'mock';\n\nif (!params.amount) {\n  return [{json: {reply: `I couldn't parse your deposit request. Try: \"deposit $100\" or \"deposit 50 on Base\"`}}];\n}\n\n// Constants\nconst GATEWAY_WALLET = '0x77777777Dcc4d5A8B6E418Fd04D8997ef11000eE';\nconst USDC_ADDRESSES = {\n  1: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n  42161: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',\n  8453: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'\n};\nconst RPC_URLS = {\n  1: 'https://eth.llamarpc.com',\n  42161: $env.RPC_ARBITRUM || 'https://arb1.arbitrum.io/rpc',\n  8453: $env.RPC_BASE || 'https://mainnet.base.org'\n};\nconst EXPLORERS = { 1: 'https://etherscan.io', 42161: 'https://arbiscan.io', 8453: 'https://basescan.org' };\nconst chainIds = { 'ethereum': 1, 'arbitrum': 42161, 'base': 8453 };\nconst chainNames = { 1: 'Ethereum', 42161: 'Arbitrum', 8453: 'Base' };\n\nconst chainName = (params.chain || 'arbitrum').toLowerCase();\nconst chainId = chainIds[chainName] || 42161;\nconst displayChain = chainNames[chainId];\n\nif (executionMode === 'mock') {\n  const mockTxHash = '0xmock_' + Date.now().toString(16) + '_deposit';\n  return [{json: {reply: `**Deposit Simulated (Mock Mode)**\\n\\nAmount: $${params.amount} USDC\\nChain: ${displayChain}\\nTx Hash: \\`${mockTxHash}\\`\\n\\n_Switch to live mode for real deposits._`}}];\n}\n\n// Live mode - require ethers only when needed\ntry {\n  const { ethers } = require('ethers');\n  const privateKey = $env.TREASURY_PRIVATE_KEY;\n  const treasuryAddress = $env.TREASURY_ADDRESS;\n  if (!privateKey || !treasuryAddress) {\n    return [{json: {reply: `**Error**: Treasury wallet not configured.`}}];\n  }\n\n  const provider = new ethers.JsonRpcProvider(RPC_URLS[chainId]);\n  const wallet = new ethers.Wallet(privateKey, provider);\n  const usdcAddress = USDC_ADDRESSES[chainId];\n  const amountParsed = ethers.parseUnits(params.amount.toString(), 6);\n\n  // ABIs\n  const erc20Abi = ['function approve(address,uint256) returns (bool)', 'function allowance(address,address) view returns (uint256)', 'function balanceOf(address) view returns (uint256)'];\n  const gatewayAbi = ['function deposit(address token, uint256 value)'];\n\n  const usdc = new ethers.Contract(usdcAddress, erc20Abi, wallet);\n  const gateway = new ethers.Contract(GATEWAY_WALLET, gatewayAbi, wallet);\n\n  // Check balance\n  const balance = await usdc.balanceOf(wallet.address);\n  if (balance < amountParsed) {\n    const balFormatted = ethers.formatUnits(balance, 6);\n    return [{json: {reply: `**Insufficient Balance**\\n\\nRequested: $${params.amount} USDC\\nAvailable: $${balFormatted} USDC on ${displayChain}\\n\\nDeposit more USDC to the treasury wallet first.`}}];\n  }\n\n  // Check allowance and approve if needed\n  const allowance = await usdc.allowance(wallet.address, GATEWAY_WALLET);\n  let approveTxHash = null;\n  if (allowance < amountParsed) {\n    const approveTx = await usdc.approve(GATEWAY_WALLET, amountParsed);\n    const approveReceipt = await approveTx.wait();\n    approveTxHash = approveReceipt.hash;\n  }\n\n  // Execute deposit to Circle Gateway\n  const depositTx = await gateway.deposit(usdcAddress, amountParsed);\n  const depositReceipt = await depositTx.wait();\n  const depositTxHash = depositReceipt.hash;\n\n  const explorerUrl = `${EXPLORERS[chainId]}/tx/${depositTxHash}`;\n  return [{json: {reply: `**Deposit Successful!**\\n\\nAmount: $${params.amount} USDC\\nChain: ${displayChain}\\nTx: [${depositTxHash.slice(0,10)}...](${explorerUrl})\\n\\n_USDC deposited to Circle Gateway_`}}];\n\n} catch (error) {\n  return [{json: {reply: `**Deposit Failed**\\n\\nError: ${error.message}\\n\\nPlease try again or use the dashboard.`}}];\n}"
      }
    },
    {
      "id": "check-ens",
      "name": "Check if ENS",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [850, 625],
      "parameters": {
        "conditions": {
          "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "loose", "caseSensitive": false},
          "combinator": "and",
          "conditions": [{"id": "ens-check", "operator": {"type": "string", "operation": "endsWith"}, "leftValue": "={{ $json.params?.recipient || '' }}", "rightValue": ".eth"}]
        },
        "options": {}
      }
    },
    {
      "id": "resolve-ens",
      "name": "Resolve ENS Name",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1050, 575],
      "onError": "continueRegularOutput",
      "parameters": {
        "method": "POST",
        "url": "=https://gateway.thegraph.com/api/{{ $env.GRAPH_API_KEY }}/subgraphs/id/5XqPmWe6gjyrJtFn9cLy237i4cWw2j9HcUJEXsP5qGtH",
        "sendHeaders": true,
        "headerParameters": {"parameters": [{"name": "Content-Type", "value": "application/json"}]},
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={ \"query\": \"{ domains(where: { name: \\\"{{ $json.params.recipient }}\\\" }) { resolvedAddress { id } } }\" }",
        "options": {"response": {"response": {"neverError": true}}}
      }
    },
    {
      "id": "format-send-ens",
      "name": "Format Send (ENS)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 575],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const ensData = $input.first().json;\nconst prev = $node['Check if ENS'].json;\nconst params = prev.params || {};\nconst token = params.token || 'USDC';\nconst recipient = params.recipient;\n\nconst addr = ensData?.data?.domains?.[0]?.resolvedAddress?.id;\nif (!addr) {\n  return [{json: {reply: `Could not resolve ENS name **${recipient}**. Please check the name and try again.`}}];\n}\n\nconst ensLabel = `${recipient} -> ${addr.slice(0,6)}...${addr.slice(-4)}`;\nreturn [{json: {reply: `**Send Request**\\n\\nAmount: ${params.amount} ${token}\\nTo: **${recipient}** (${ensLabel})\\n\\nThis will be routed via Circle Gateway for USDC transfers.\\n\\n_Use the dashboard to confirm and execute this transfer._`}}];"
      }
    },
    {
      "id": "format-send-addr",
      "name": "Format Send (Address)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 700],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const params = $input.first().json.params || {};\nconst token = params.token || 'USDC';\n\nif (!params.amount || !params.recipient) {\n  return [{json: {reply: `I couldn't parse your send request. Try: \"send 50 USDC to vitalik.eth\" or \"send 100 USDC to 0x1234...\"`}}];\n}\n\nreturn [{json: {reply: `**Send Request**\\n\\nAmount: ${params.amount} ${token}\\nTo: **${params.recipient}**\\n\\nThis will be routed via Circle Gateway for USDC transfers.\\n\\n_Use the dashboard to confirm and execute this transfer._`}}];"
      }
    },
    {
      "id": "format-help",
      "name": "Format Help Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 700],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "return [{json: {reply: `**PigAiBank Commands**\\n\\n**Check Balance**\\n\"What's our balance?\" or \"balance\"\\n\\n**Check Prices**\\n\"ETH price\" or \"What's the price of ETH?\"\\n\\n**Swap Tokens**\\n\"Swap 100 USDC to ETH\"\\n\\n**Deposit USDC**\\n\"Deposit $100\" or \"Deposit 50 on Base\"\\n\\n**Send Funds**\\n\"Send 50 USDC to vitalik.eth\"\\n\\n_Powered by Circle Gateway, Uniswap, and LI.FI_`}}];"
      }
    },
    {
      "id": "format-unknown",
      "name": "Format Unknown Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 850],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const content = $input.first().json.originalContent || '';\nconst intent = $input.first().json.intent;\nif (intent === 'greeting') {\n  return [{json: {reply: `Hey! I'm PigAiBank. I can help you check balances, prices, execute swaps, and deposit USDC. Try \"balance\" or \"help\" to get started!`}}];\n}\nreturn [{json: {reply: `I'm not sure what you mean by \"${content.substring(0, 50)}\"...\\n\\nTry \"help\" to see what I can do!`}}];"
      }
    },
    {
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1250, 400],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      }
    }
  ],
  "connections": {
    "Discord Command Webhook": {
      "main": [[{"node": "Parse Intent", "type": "main", "index": 0}]]
    },
    "Parse Intent": {
      "main": [[{"node": "Route by Intent", "type": "main", "index": 0}]]
    },
    "Route by Intent": {
      "main": [
        [{"node": "Get Gateway Balance", "type": "main", "index": 0}],
        [{"node": "Get ETH Price", "type": "main", "index": 0}],
        [{"node": "Create Swap Quote", "type": "main", "index": 0}],
        [{"node": "Handle Deposit", "type": "main", "index": 0}],
        [{"node": "Check if ENS", "type": "main", "index": 0}],
        [{"node": "Format Help Response", "type": "main", "index": 0}],
        [{"node": "Handle Confirm/Cancel", "type": "main", "index": 0}],
        [{"node": "Format Unknown Response", "type": "main", "index": 0}]
      ]
    },
    "Get Gateway Balance": {
      "main": [[{"node": "Format Balance Response", "type": "main", "index": 0}]]
    },
    "Get ETH Price": {
      "main": [[{"node": "Format Price Response", "type": "main", "index": 0}]]
    },
    "Format Balance Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Format Price Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Create Swap Quote": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Handle Confirm/Cancel": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Handle Deposit": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Check if ENS": {
      "main": [
        [{"node": "Resolve ENS Name", "type": "main", "index": 0}],
        [{"node": "Format Send (Address)", "type": "main", "index": 0}]
      ]
    },
    "Resolve ENS Name": {
      "main": [[{"node": "Format Send (ENS)", "type": "main", "index": 0}]]
    },
    "Format Send (ENS)": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Format Send (Address)": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Format Help Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Format Unknown Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "pinData": {}
}
