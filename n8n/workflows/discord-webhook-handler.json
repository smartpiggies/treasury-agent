{
  "name": "Discord Webhook Handler",
  "nodes": [
    {
      "id": "webhook-trigger",
      "name": "Discord Command Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "discord-cmd",
      "parameters": {
        "path": "discord-cmd",
        "httpMethod": "POST",
        "responseMode": "responseNode",
        "options": {}
      }
    },
    {
      "id": "parse-intent",
      "name": "Parse Intent",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const fetch = require('node-fetch');\nconst content = $input.first().json.body?.content || $input.first().json.content || '';\nconst inputData = $input.first().json.body || $input.first().json;\n\n// Normalize chain abbreviations\nfunction normalizeChain(c) {\n  if (!c) return null;\n  const lc = c.toLowerCase();\n  if (lc === 'arb' || lc === 'arbitrum') return 'arbitrum';\n  if (lc === 'base') return 'base';\n  if (lc === 'eth' || lc === 'ethereum' || lc === 'mainnet') return 'ethereum';\n  return null;\n}\n\n// Keyword fallback (used if LLM call fails)\nfunction keywordFallback(text) {\n  const lc = text.toLowerCase().trim();\n  let intent = 'unknown';\n  let params = {};\n  if (/^(confirm|yes|do it|execute|go|proceed|sure|yeah|yep|let'?s go|go ahead|approved|ok|okay)$/i.test(lc)) {\n    intent = 'confirm'; params.action = 'confirm';\n  } else if (/^(cancel|abort|no|stop|nevermind|never mind|nah|forget it|nope|decline)$/i.test(lc)) {\n    intent = 'confirm'; params.action = 'cancel';\n  } else if (lc.includes('deposit')) {\n    intent = 'deposit';\n    const m = lc.match(/deposit\\s*\\$?(\\d+(?:\\.\\d+)?)(?:\\s+(?:usdc|bucks?|dollars?))?(?:\\s+(?:on|to)\\s+(ethereum|arbitrum|base|arb|eth))?/i);\n    if (m) { params.amount = m[1]; params.chain = normalizeChain(m[2]) || 'arbitrum'; }\n  } else if (lc.includes('swap') || lc.includes('convert') || lc.includes('exchange')) {\n    intent = 'swap';\n    // Strip chain prefixes and suffixes for token matching\n    let cleaned = lc.replace(/\\b(on|to)\\s+(arb|arbitrum|base|eth|ethereum|mainnet)\\b/g, '').trim();\n    cleaned = cleaned.replace(/\\b(arb|arbitrum|base|ethereum|mainnet)\\s+(?=usdc|eth|usdt)/g, '').trim();\n    // Pattern 1: \"swap [amount] [token] to/for [token]\" (selling amount)\n    let m = cleaned.match(/(\\d*\\.?\\d+)\\s*(usdc|eth|usdt)\\s*(?:to|for|into)\\s*(usdc|eth|usdt)/i);\n    if (m) { params.amount = m[1]; params.fromToken = m[2].toUpperCase(); params.toToken = m[3].toUpperCase(); }\n    if (!m) {\n      // Pattern 2: \"swap [token] for [amount] [token]\" (wanting toAmount)\n      m = cleaned.match(/(usdc|eth|usdt)\\s*(?:for|to|into)\\s*(\\d*\\.?\\d+)\\s*(usdc|eth|usdt)/i);\n      if (m) { params.fromToken = m[1].toUpperCase(); params.toAmount = m[2]; params.toToken = m[3].toUpperCase(); }\n    }\n    // Extract chains from original text - find all on-chain occurrences\n    const chainBefore = lc.match(/(?:swap|convert|exchange)\\s+(arb|arbitrum|base|ethereum|mainnet)\\s+/i);\n    const allOnChain = [...lc.matchAll(/(?:on|to)\\s+(arb|arbitrum|base|ethereum|mainnet)/gi)].map(m => normalizeChain(m[1]));\n    if (chainBefore) params.sourceChain = normalizeChain(chainBefore[1]);\n    if (allOnChain.length >= 2) {\n      // Two chain mentions: first is source, second is dest\n      params.sourceChain = params.sourceChain || allOnChain[0];\n      params.destChain = allOnChain[1];\n    } else if (allOnChain.length === 1) {\n      const c = allOnChain[0];\n      if (!params.sourceChain) params.sourceChain = c;\n      params.destChain = c;\n    }\n    if (params.sourceChain && !params.destChain) params.destChain = params.sourceChain;\n  } else if (lc.includes('send') || lc.includes('transfer')) {\n    intent = 'send';\n    const m = lc.match(/(\\d+(?:\\.\\d+)?)\\s*(usdc|eth)\\s*(?:to)\\s*([\\w\\.]+)/i);\n    if (m) { params.amount = m[1]; params.token = m[2].toUpperCase(); params.recipient = m[3]; }\n  } else if (lc.includes('balance') || lc.includes('how much')) {\n    intent = 'balance';\n  } else if (lc.includes('price') || /^(eth|bitcoin|btc)\\s*\\??$/.test(lc)) {\n    intent = 'price';\n    params.token = (lc.includes('btc') || lc.includes('bitcoin')) ? 'BTC' : 'ETH';\n  } else if (lc.includes('help') || lc === '?') {\n    intent = 'help';\n  } else if (/^(hi|hello|hey|gm|good morning)/.test(lc)) {\n    intent = 'greeting';\n  }\n  return { intent, params };\n}\n\n// LLM intent parsing via OpenRouter\nconst OPENROUTER_API_KEY = $env.OPENROUTER_API_KEY;\nlet intent = 'unknown';\nlet params = {};\nlet llmReply = '';\n\nif (!OPENROUTER_API_KEY) {\n  const fb = keywordFallback(content);\n  intent = fb.intent;\n  params = fb.params;\n} else {\n  try {\n    const systemPrompt = `You are PigAiBank's intent parser. Given a Discord message, classify the intent and extract parameters.\n\nReturn JSON only (no markdown fences, no extra text):\n{\n  \"intent\": \"balance\"|\"price\"|\"swap\"|\"deposit\"|\"send\"|\"confirm\"|\"help\"|\"greeting\"|\"unknown\",\n  \"params\": { ... },\n  \"reply\": \"optional natural language reply for greeting/unknown/help intents\"\n}\n\nIntent rules:\n- \"confirm\": User is confirming a pending action (yes, confirm, do it, go ahead, sure, proceed, execute, yeah, yep, let's go, ok, okay, approved)\n  → params: { \"action\": \"confirm\" }\n- \"cancel\": User is cancelling/declining a pending action (no, cancel, abort, stop, nevermind, nah, forget it, nope, decline)\n  → intent must be \"confirm\", params: { \"action\": \"cancel\" }\n- \"balance\": User asks about treasury balance, funds, how much we have\n  → params: {}\n- \"price\": User asks about token prices (ETH, BTC, etc)\n  → params: { \"token\": \"ETH\" or \"BTC\" }\n- \"swap\": User wants to exchange/swap/convert tokens\n  → params: { \"fromToken\": \"ETH\", \"toToken\": \"USDC\", \"sourceChain\": \"arbitrum\", \"destChain\": \"arbitrum\" } plus ONE of:\n    - \"amount\": amount of fromToken to SELL (e.g. \"swap 0.5 ETH to USDC\" → amount=\"0.5\", fromToken=\"ETH\")\n    - \"toAmount\": desired amount of toToken to RECEIVE (e.g. \"swap ETH for 0.38 USDC\" → toAmount=\"0.38\", fromToken=\"ETH\", toToken=\"USDC\")\n  CRITICAL: The number belongs to whichever token it is next to. \"swap ETH for .38 USDC\" means toAmount=\".38\" (user wants to RECEIVE .38 USDC). \"swap .38 ETH to USDC\" means amount=\".38\" (user is SELLING .38 ETH). Getting this wrong can cost hundreds of dollars.\n  Chain handling: Users may specify source and destination chains SEPARATELY. Normalize abbreviations: arb/arbitrum→\"arbitrum\", base→\"base\", eth/ethereum/mainnet→\"ethereum\".\n  Cross-chain examples:\n    - \"swap .0001 ETH on Arb for USDC on base\" → sourceChain=\"arbitrum\", destChain=\"base\", amount=\".0001\", fromToken=\"ETH\", toToken=\"USDC\"\n    - \"swap 1 USDC on base to ETH on arb\" → sourceChain=\"base\", destChain=\"arbitrum\", amount=\"1\", fromToken=\"USDC\", toToken=\"ETH\"\n    - \"swap arb ETH to base USDC\" → sourceChain=\"arbitrum\", destChain=\"base\"\n  The chain BEFORE or AFTER the source token is sourceChain. The chain BEFORE or AFTER the dest token is destChain. If only one chain is mentioned, use it for both.\n  Default both to \"arbitrum\" if not specified. IMPORTANT: \"arb ETH\" or \"base USDC\" means the chain, NOT a token — do not confuse chain names with token symbols.\n- \"deposit\": User wants to deposit USDC to Circle Gateway\n  → params: { \"amount\": \"...\", \"chain\": \"arbitrum\"|\"base\"|\"ethereum\" } (default chain: \"arbitrum\")\n- \"send\": User wants to send/transfer tokens to an address or ENS name\n  → params: { \"amount\": \"...\", \"token\": \"USDC\", \"recipient\": \"...\" }\n- \"help\": User asks what the bot can do\n  → params: {}\n- \"greeting\": Hi, hello, gm, hey, etc.\n  → params: {}, reply: short friendly greeting mentioning you can help with balances, swaps, etc.\n- \"unknown\": Can't determine intent\n  → params: {}, reply: helpful suggestion of what the user can try\n\nIMPORTANT: For \"cancel\" intent, set intent to \"confirm\" with params.action = \"cancel\". The amount field should always be a string. Token symbols should be uppercase.`;\n\n    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer ' + OPENROUTER_API_KEY,\n        'HTTP-Referer': 'https://treasury-agent.sites.smartpiggies.cloud',\n        'X-Title': 'PigAiBank Intent Parser',\n      },\n      body: JSON.stringify({\n        model: 'moonshotai/kimi-k2.5',\n        messages: [\n          { role: 'system', content: systemPrompt },\n          { role: 'user', content: content },\n        ],\n        temperature: 0,\n        max_tokens: 256,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error('OpenRouter HTTP ' + response.status);\n    }\n\n    const data = await response.json();\n    let raw = (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) || '';\n\n    // Strip markdown code fences if present\n    raw = raw.replace(/^```(?:json)?\\s*/i, '').replace(/\\s*```$/i, '').trim();\n    // Extract JSON object if embedded in other text\n    const jsonMatch = raw.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) raw = jsonMatch[0];\n\n    const parsed = JSON.parse(raw);\n    intent = parsed.intent || 'unknown';\n    params = parsed.params || {};\n    llmReply = parsed.reply || '';\n\n    // Validate intent is one of the known values\n    const validIntents = ['balance','price','swap','deposit','send','confirm','help','greeting','unknown'];\n    if (!validIntents.includes(intent)) {\n      intent = 'unknown';\n    }\n  } catch (err) {\n    // LLM call failed — fall back to keyword matching\n    const fb = keywordFallback(content);\n    intent = fb.intent;\n    params = fb.params;\n  }\n}\n\nreturn [{json: {...inputData, intent, params, llmReply, originalContent: content}}];"
      }
    },
    {
      "id": "route-intent",
      "name": "Route by Intent",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [650, 300],
      "parameters": {
        "rules": {
          "values": [
            {
              "outputKey": "balance",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "balance-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "balance"}]
              }
            },
            {
              "outputKey": "price",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "price-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "price"}]
              }
            },
            {
              "outputKey": "swap",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "swap-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "swap"}]
              }
            },
            {
              "outputKey": "deposit",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "deposit-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "deposit"}]
              }
            },
            {
              "outputKey": "send",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "send-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "send"}]
              }
            },
            {
              "outputKey": "help",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "help-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "help"}]
              }
            },
            {
              "outputKey": "confirm",
              "conditions": {
                "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "strict", "caseSensitive": true},
                "combinator": "and",
                "conditions": [{"id": "confirm-cond", "operator": {"type": "string", "operation": "equals"}, "leftValue": "={{ $json.intent }}", "rightValue": "confirm"}]
              }
            }
          ]
        },
        "options": {"fallbackOutput": "extra"}
      }
    },
    {
      "id": "get-circle-balance",
      "name": "Get Gateway Balance",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 100],
      "onError": "continueRegularOutput",
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Fetch Gateway balances from Circle REST API (accurate available balance)\nconst fetch = require('node-fetch');\nconst CIRCLE_GATEWAY_URL = $env.CIRCLE_GATEWAY_URL || 'https://gateway-api.circle.com';\nconst depositor = $env.TREASURY_ADDRESS;\n\nconst sources = [\n  { domain: 0, depositor },\n  { domain: 3, depositor },\n  { domain: 6, depositor },\n];\n\nconst response = await fetch(`${CIRCLE_GATEWAY_URL}/v1/balances`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ token: 'USDC', sources }),\n});\n\nif (!response.ok) {\n  const body = await response.text();\n  throw new Error(`Circle API error ${response.status}: ${body}`);\n}\n\nconst data = await response.json();\nreturn [{ json: { balances: data.balances, token: data.token } }];"
      }
    },
    {
      "id": "format-balance",
      "name": "Format Balance Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 100],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const data = $input.first().json;\nconst author = $node['Parse Intent'].json.author?.displayName || 'there';\n\n// Check for errors\nif (data.error || (data.message && !data.balances)) {\n  return [{json: {reply: `Hey ${author}! Error fetching balance: ${data.message || data.error}`}}];\n}\n\n// Parse Circle Gateway response (new format: balance is string like \"1000.50\")\nconst balances = data.balances || [];\nlet totalUsdc = 0;\nconst chainBalances = [];\nconst domainNames = {0: 'Ethereum', 3: 'Arbitrum', 6: 'Base'};\n\nfor (const bal of balances) {\n  // New API returns 'balance' as formatted string (e.g., \"1000.50\")\n  const amount = parseFloat(bal.balance || bal.amount || '0');\n  totalUsdc += amount;\n  if (amount > 0) {\n    chainBalances.push(`${domainNames[bal.domain] || 'Chain ' + bal.domain}: $${amount.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`);\n  }\n}\n\nconst balanceList = chainBalances.length > 0 \n  ? chainBalances.join('\\n- ') \n  : 'No USDC balances found (deposit USDC to Gateway first)';\n\nconst totalFormatted = totalUsdc.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});\n\nreturn [{json: {reply: `Hey ${author}! Here's your treasury balance:\\n\\n**Total USDC: $${totalFormatted}**\\n- ${balanceList}\\n\\n_Powered by Circle Gateway_`}}];"
      }
    },
    {
      "id": "get-eth-price",
      "name": "Get ETH Price",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 250],
      "onError": "continueRegularOutput",
      "parameters": {
        "method": "POST",
        "url": "=https://gateway.thegraph.com/api/{{ $env.GRAPH_API_KEY }}/subgraphs/id/{{ $env.GRAPH_SUBGRAPH_ARBITRUM }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [{"name": "Content-Type", "value": "application/json"}]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"query\": \"{ bundles(first: 1) { ethPriceUSD } }\"}",
        "options": {"response": {"response": {"neverError": true}}}
      }
    },
    {
      "id": "format-price",
      "name": "Format Price Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 250],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const data = $input.first().json;\nconst ethPrice = parseFloat(data?.data?.bundles?.[0]?.ethPriceUSD || 0);\nif (ethPrice === 0) {\n  return [{json: {reply: 'Error fetching price'}}];\n}\nconst formatted = ethPrice.toLocaleString('en-US', {style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2});\nreturn [{json: {reply: `**ETH Price**: ${formatted}\\n\\n_Data from Uniswap v3 on Arbitrum via The Graph_`}}];"
      }
    },
    {
      "id": "create-swap-quote",
      "name": "Create Swap Quote",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 400],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const fetch = require('node-fetch');\nconst params = $input.first().json.params || {};\nconst author = $input.first().json.author?.displayName || 'there';\n\nconst hasAmount = params.amount && params.amount !== '';\nconst hasToAmount = params.toAmount && params.toAmount !== '';\n\nif ((!hasAmount && !hasToAmount) || !params.fromToken || !params.toToken) {\n  return [{json: {reply: `I couldn't parse your swap request. Try: \"swap 0.01 USDC to ETH\" or \"swap 0.001 ETH to USDC\"`}}];\n}\n\n// Exact-output swaps not yet supported — ask user to specify sell amount\nif (hasToAmount && !hasAmount) {\n  return [{json: {reply: `I understand you want to receive **${params.toAmount} ${params.toToken}**, but I need to know how much **${params.fromToken}** to sell.\\n\\nTry specifying the sell amount instead:\\n\"swap 0.001 ${params.fromToken} to ${params.toToken}\"`}}];\n}\n\n// Determine chains (from LLM params or default to arbitrum)\nconst sourceChain = (params.sourceChain || 'arbitrum').toLowerCase();\nconst destChain = (params.destChain || sourceChain).toLowerCase();\nlet route = 'uniswap';\nif (sourceChain !== destChain) {\n  route = (params.fromToken === 'USDC' && params.toToken === 'USDC') ? 'circle' : 'lifi';\n} else if (params.fromToken === 'USDC' && params.toToken === 'USDC') {\n  route = 'circle';\n}\n\nconst chainLabel = sourceChain === destChain ? sourceChain.charAt(0).toUpperCase() + sourceChain.slice(1) : sourceChain.charAt(0).toUpperCase() + sourceChain.slice(1) + ' \\u2192 ' + destChain.charAt(0).toUpperCase() + destChain.slice(1);\n\n// Create pending execution in Appwrite\nconst appwriteEndpoint = $env.APPWRITE_ENDPOINT || 'https://aw.smartpiggies.cloud/v1';\nconst dbId = $env.APPWRITE_DATABASE_ID || 'treasury';\nconst projectId = $env.APPWRITE_PROJECT_ID || 'treasury-agent-1';\nconst apiKey = $env.APPWRITE_API_KEY;\n\ntry {\n  const response = await fetch(\n    `${appwriteEndpoint}/databases/${dbId}/collections/executions/documents`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n      body: JSON.stringify({\n        documentId: 'unique()',\n        data: {\n          timestamp: new Date().toISOString(),\n          type: 'swap',\n          source_chain: sourceChain,\n          dest_chain: destChain,\n          source_token: params.fromToken.toUpperCase(),\n          dest_token: params.toToken.toUpperCase(),\n          amount: params.amount.toString(),\n          status: 'pending',\n          route: route,\n          requester: 'discord',\n        },\n      }),\n    }\n  );\n\n  if (!response.ok) {\n    const errBody = await response.text();\n    throw new Error(`Appwrite ${response.status}: ${errBody}`);\n  }\n\n  const doc = await response.json();\n  const executionId = doc.$id;\n\n  const routeLabel = route === 'uniswap' ? 'Uniswap v4 (same-chain)' : route === 'circle' ? 'Circle Gateway' : 'LI.FI';\n\n  return [{json: {reply: `**Swap Quote**\\n\\nSell: ${params.amount} ${params.fromToken}\\nBuy: ${params.toToken}\\nChain: ${chainLabel}\\nRoute: ${routeLabel}\\nExecution ID: \\`${executionId}\\`\\n\\n_Reply **confirm** to execute or **cancel** to abort._`}}];\n} catch (error) {\n  return [{json: {reply: `**Error creating swap quote**: ${error.message}\\n\\nPlease try again.`}}];\n}"
      }
    },
    {
      "id": "handle-confirm",
      "name": "Handle Confirm/Cancel",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 475],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const fetch = require('node-fetch');\nconst action = $input.first().json.params?.action || 'confirm';\n\nconst appwriteEndpoint = $env.APPWRITE_ENDPOINT || 'https://aw.smartpiggies.cloud/v1';\nconst dbId = $env.APPWRITE_DATABASE_ID || 'treasury';\nconst projectId = $env.APPWRITE_PROJECT_ID || 'treasury-agent-1';\nconst apiKey = $env.APPWRITE_API_KEY;\n\ntry {\n  // Query Appwrite for the latest pending execution (JSON method format)\n  const queries = [\n    JSON.stringify({method: 'equal', attribute: 'status', values: ['pending']}),\n    JSON.stringify({method: 'orderDesc', attribute: '$createdAt'}),\n    JSON.stringify({method: 'limit', values: [1]}),\n  ];\n  const qs = queries.map(q => 'queries[]=' + encodeURIComponent(q)).join('&');\n\n  const listResponse = await fetch(\n    `${appwriteEndpoint}/databases/${dbId}/collections/executions/documents?${qs}`,\n    {\n      headers: {\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n    }\n  );\n\n  if (!listResponse.ok) {\n    const errBody = await listResponse.text();\n    throw new Error(`Appwrite list ${listResponse.status}: ${errBody}`);\n  }\n\n  const listData = await listResponse.json();\n\n  if (!listData.documents || listData.documents.length === 0) {\n    return [{json: {reply: `No pending swap found. Use **swap [amount] [token] to [token]** to create one first.`}}];\n  }\n\n  const pendingExec = listData.documents[0];\n  const executionId = pendingExec.$id;\n\n  if (action === 'cancel') {\n    // Cancel directly via Appwrite PATCH\n    const cancelResponse = await fetch(\n      `${appwriteEndpoint}/databases/${dbId}/collections/executions/documents/${executionId}`,\n      {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Appwrite-Project': projectId,\n          'X-Appwrite-Key': apiKey,\n        },\n        body: JSON.stringify({\n          data: {\n            status: 'cancelled',\n            completed_at: new Date().toISOString(),\n          },\n        }),\n      }\n    );\n\n    if (!cancelResponse.ok) {\n      const errBody = await cancelResponse.text();\n      throw new Error(`Cancel failed ${cancelResponse.status}: ${errBody}`);\n    }\n\n    return [{json: {reply: `**Swap Cancelled**\\n\\nExecution \\`${executionId}\\` has been cancelled.\\n${pendingExec.amount} ${pendingExec.source_token} → ${pendingExec.dest_token} will not be executed.`}}];\n  }\n\n  // Confirm: call the swap-confirm webhook\n  const n8nBaseUrl = 'https://n8n.smartpiggies.cloud';\n  const confirmResponse = await fetch(\n    `${n8nBaseUrl}/webhook/swap-confirm`,\n    {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ executionId, action: 'confirm' }),\n    }\n  );\n\n  const confirmResult = await confirmResponse.json();\n\n  if (confirmResult.success) {\n    const txHash = confirmResult.txHash || confirmResult.tx_hash || 'N/A';\n    const explorers = { ethereum: 'etherscan.io', arbitrum: 'arbiscan.io', base: 'basescan.org', optimism: 'optimistic.etherscan.io', polygon: 'polygonscan.com' };\n    const sourceChain = pendingExec.source_chain || 'arbitrum';\n    const destChain = pendingExec.dest_chain || sourceChain;\n    const isCrossChain = sourceChain !== destChain;\n    const isReal = txHash && txHash !== 'N/A' && !txHash.startsWith('0xmock');\n    const route = pendingExec.route;\n    // For Gateway/Circle, txHash is on dest chain; for LI.FI/Uniswap, txHash is on source chain\n    const txChain = (route === 'circle' || route === 'gateway') ? destChain : sourceChain;\n    const txExplorer = explorers[txChain] || 'arbiscan.io';\n    const txLink = isReal ? `[${txHash.substring(0,10)}...${txHash.substring(txHash.length-6)}](https://${txExplorer}/tx/${txHash})` : `\\`${txHash}\\``;\n    // Build cross-chain tracking line\n    let crossChainLine = '';\n    if (isCrossChain && isReal && route === 'lifi') {\n      crossChainLine = `\\nDest: [Track on LI.FI Explorer](https://explorer.li.fi/tx/${txHash})`;\n    } else if (isCrossChain && isReal && (route === 'circle' || route === 'gateway')) {\n      crossChainLine = `\\nDest: [View on ${explorers[destChain] || 'arbiscan.io'}](https://${explorers[destChain] || 'arbiscan.io'}/tx/${txHash})`;\n    }\n    return [{json: {reply: `**Swap Executed!**\\n\\nExecution: \\`${executionId}\\`\\n${pendingExec.amount} ${pendingExec.source_token} → ${pendingExec.dest_token}\\nTx: ${txLink}${crossChainLine}\\n\\n_Powered by ${route === 'circle' ? 'Circle Gateway' : route === 'uniswap' ? 'Uniswap v4' : 'LI.FI'}_`}}];\n  } else {\n    const errorMsg = confirmResult.error || confirmResult.message || 'Unknown error';\n    return [{json: {reply: `**Swap Failed**\\n\\nExecution: \\`${executionId}\\`\\nError: ${errorMsg}\\n\\nPlease try again or check the dashboard.`}}];\n  }\n} catch (error) {\n  return [{json: {reply: `**Error**: ${error.message}`}}];\n}"
      }
    },
    {
      "id": "handle-deposit",
      "name": "Handle Deposit",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 550],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const params = $input.first().json.params || {};\nconst author = $input.first().json.author?.displayName || 'there';\nconst executionMode = $env.EXECUTION_MODE || 'mock';\n\nif (!params.amount) {\n  return [{json: {reply: `I couldn't parse your deposit request. Try: \"deposit $100\" or \"deposit 50 on Base\"`}}];\n}\n\n// Constants\nconst GATEWAY_WALLET = '0x77777777Dcc4d5A8B6E418Fd04D8997ef11000eE';\nconst USDC_ADDRESSES = {\n  1: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',\n  42161: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831',\n  8453: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'\n};\nconst RPC_URLS = {\n  1: 'https://eth.llamarpc.com',\n  42161: $env.RPC_ARBITRUM || 'https://arb1.arbitrum.io/rpc',\n  8453: $env.RPC_BASE || 'https://mainnet.base.org'\n};\nconst EXPLORERS = { 1: 'https://etherscan.io', 42161: 'https://arbiscan.io', 8453: 'https://basescan.org' };\nconst chainIds = { 'ethereum': 1, 'arbitrum': 42161, 'base': 8453 };\nconst chainNames = { 1: 'Ethereum', 42161: 'Arbitrum', 8453: 'Base' };\n\nconst chainName = (params.chain || 'arbitrum').toLowerCase();\nconst chainId = chainIds[chainName] || 42161;\nconst displayChain = chainNames[chainId];\n\nif (executionMode === 'mock') {\n  const mockTxHash = '0xmock_' + Date.now().toString(16) + '_deposit';\n  return [{json: {reply: `**Deposit Simulated (Mock Mode)**\\n\\nAmount: $${params.amount} USDC\\nChain: ${displayChain}\\nTx Hash: \\`${mockTxHash}\\`\\n\\n_Switch to live mode for real deposits._`}}];\n}\n\n// Live mode - require ethers only when needed\ntry {\n  const { ethers } = require('ethers');\n  const privateKey = $env.TREASURY_PRIVATE_KEY;\n  const treasuryAddress = $env.TREASURY_ADDRESS;\n  if (!privateKey || !treasuryAddress) {\n    return [{json: {reply: `**Error**: Treasury wallet not configured.`}}];\n  }\n\n  const provider = new ethers.JsonRpcProvider(RPC_URLS[chainId]);\n  const wallet = new ethers.Wallet(privateKey, provider);\n  const usdcAddress = USDC_ADDRESSES[chainId];\n  const amountParsed = ethers.parseUnits(params.amount.toString(), 6);\n\n  // ABIs\n  const erc20Abi = ['function approve(address,uint256) returns (bool)', 'function allowance(address,address) view returns (uint256)', 'function balanceOf(address) view returns (uint256)'];\n  const gatewayAbi = ['function deposit(address token, uint256 value)'];\n\n  const usdc = new ethers.Contract(usdcAddress, erc20Abi, wallet);\n  const gateway = new ethers.Contract(GATEWAY_WALLET, gatewayAbi, wallet);\n\n  // Check balance\n  const balance = await usdc.balanceOf(wallet.address);\n  if (balance < amountParsed) {\n    const balFormatted = ethers.formatUnits(balance, 6);\n    return [{json: {reply: `**Insufficient Balance**\\n\\nRequested: $${params.amount} USDC\\nAvailable: $${balFormatted} USDC on ${displayChain}\\n\\nDeposit more USDC to the treasury wallet first.`}}];\n  }\n\n  // Check allowance and approve if needed\n  const allowance = await usdc.allowance(wallet.address, GATEWAY_WALLET);\n  let approveTxHash = null;\n  if (allowance < amountParsed) {\n    const approveTx = await usdc.approve(GATEWAY_WALLET, amountParsed);\n    const approveReceipt = await approveTx.wait();\n    approveTxHash = approveReceipt.hash;\n  }\n\n  // Execute deposit to Circle Gateway\n  const depositTx = await gateway.deposit(usdcAddress, amountParsed);\n  const depositReceipt = await depositTx.wait();\n  const depositTxHash = depositReceipt.hash;\n\n  const explorerUrl = `${EXPLORERS[chainId]}/tx/${depositTxHash}`;\n  return [{json: {reply: `**Deposit Successful!**\\n\\nAmount: $${params.amount} USDC\\nChain: ${displayChain}\\nTx: [${depositTxHash.slice(0,10)}...](${explorerUrl})\\n\\n_USDC deposited to Circle Gateway_`}}];\n\n} catch (error) {\n  return [{json: {reply: `**Deposit Failed**\\n\\nError: ${error.message}\\n\\nPlease try again or use the dashboard.`}}];\n}"
      }
    },
    {
      "id": "check-ens",
      "name": "Check if ENS",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [850, 625],
      "parameters": {
        "conditions": {
          "options": {"version": 2, "combinator": "and", "leftValue": "", "typeValidation": "loose", "caseSensitive": false},
          "combinator": "and",
          "conditions": [{"id": "ens-check", "operator": {"type": "string", "operation": "endsWith"}, "leftValue": "={{ $json.params?.recipient || '' }}", "rightValue": ".eth"}]
        },
        "options": {}
      }
    },
    {
      "id": "resolve-ens",
      "name": "Resolve ENS Name",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1050, 575],
      "onError": "continueRegularOutput",
      "parameters": {
        "method": "POST",
        "url": "=https://gateway.thegraph.com/api/{{ $env.GRAPH_API_KEY }}/subgraphs/id/5XqPmWe6gjyrJtFn9cLy237i4cWw2j9HcUJEXsP5qGtH",
        "sendHeaders": true,
        "headerParameters": {"parameters": [{"name": "Content-Type", "value": "application/json"}]},
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={ \"query\": \"{ domains(where: { name: \\\"{{ $json.params.recipient }}\\\" }) { resolvedAddress { id } } }\" }",
        "options": {"response": {"response": {"neverError": true}}}
      }
    },
    {
      "id": "format-send-ens",
      "name": "Format Send (ENS)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 575],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const fetch = require('node-fetch');\nconst ensData = $input.first().json;\nconst prev = $node['Check if ENS'].json;\nconst params = prev.params || {};\nconst token = (params.token || 'ETH').toUpperCase();\nconst recipient = params.recipient;\nconst chain = (params.chain || 'arbitrum').toLowerCase();\n\nconst addr = ensData?.data?.domains?.[0]?.resolvedAddress?.id;\nif (!addr) {\n  return [{json: {reply: `Could not resolve ENS name **${recipient}**. Please check the name and try again.`}}];\n}\n\nif (!params.amount) {\n  return [{json: {reply: `I couldn't parse the amount. Try: \\\"send 0.001 ETH to ${recipient}\\\"` }}];\n}\n\nconst appwriteEndpoint = $env.APPWRITE_ENDPOINT || 'https://aw.smartpiggies.cloud/v1';\nconst dbId = $env.APPWRITE_DATABASE_ID || 'treasury';\nconst projectId = $env.APPWRITE_PROJECT_ID || 'treasury-agent-1';\nconst apiKey = $env.APPWRITE_API_KEY;\n\ntry {\n  const response = await fetch(\n    `${appwriteEndpoint}/databases/${dbId}/collections/executions/documents`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n      body: JSON.stringify({\n        documentId: 'unique()',\n        data: {\n          timestamp: new Date().toISOString(),\n          type: 'swap',\n          source_chain: chain,\n          dest_chain: chain,\n          source_token: token,\n          dest_token: token,\n          amount: params.amount.toString(),\n          status: 'pending',\n          route: 'uniswap',\n          reason: `send:${addr}:${recipient}`,\n          requester: 'discord',\n        },\n      }),\n    }\n  );\n\n  if (!response.ok) {\n    const errBody = await response.text();\n    throw new Error(`Appwrite ${response.status}: ${errBody}`);\n  }\n\n  const doc = await response.json();\n  const executionId = doc.$id;\n  const ensLabel = `${recipient} -> ${addr.slice(0,6)}...${addr.slice(-4)}`;\n\n  return [{json: {reply: `**Send Request**\\n\\nAmount: ${params.amount} ${token}\\nTo: **${recipient}** (${ensLabel})\\nChain: ${chain.charAt(0).toUpperCase() + chain.slice(1)}\\nExecution ID: \\`${executionId}\\`\\n\\n_Reply **confirm** to execute or **cancel** to abort._`}}];\n} catch (error) {\n  return [{json: {reply: `**Error creating send request**: ${error.message}`}}];\n}"
      }
    },
    {
      "id": "format-send-addr",
      "name": "Format Send (Address)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 700],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const fetch = require('node-fetch');\nconst params = $input.first().json.params || {};\nconst token = (params.token || 'ETH').toUpperCase();\nconst chain = (params.chain || 'arbitrum').toLowerCase();\n\nif (!params.amount || !params.recipient) {\n  return [{json: {reply: `I couldn't parse your send request. Try: \\\"send 0.001 ETH to vitalik.eth\\\" or \\\"send 1 USDC to 0x1234...\\\"`}}];\n}\n\nconst addr = params.recipient;\nconst appwriteEndpoint = $env.APPWRITE_ENDPOINT || 'https://aw.smartpiggies.cloud/v1';\nconst dbId = $env.APPWRITE_DATABASE_ID || 'treasury';\nconst projectId = $env.APPWRITE_PROJECT_ID || 'treasury-agent-1';\nconst apiKey = $env.APPWRITE_API_KEY;\n\ntry {\n  const response = await fetch(\n    `${appwriteEndpoint}/databases/${dbId}/collections/executions/documents`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n      body: JSON.stringify({\n        documentId: 'unique()',\n        data: {\n          timestamp: new Date().toISOString(),\n          type: 'swap',\n          source_chain: chain,\n          dest_chain: chain,\n          source_token: token,\n          dest_token: token,\n          amount: params.amount.toString(),\n          status: 'pending',\n          route: 'uniswap',\n          reason: `send:${addr}`,\n          requester: 'discord',\n        },\n      }),\n    }\n  );\n\n  if (!response.ok) {\n    const errBody = await response.text();\n    throw new Error(`Appwrite ${response.status}: ${errBody}`);\n  }\n\n  const doc = await response.json();\n  const executionId = doc.$id;\n\n  return [{json: {reply: `**Send Request**\\n\\nAmount: ${params.amount} ${token}\\nTo: **${addr.substring(0,10)}...${addr.substring(addr.length-6)}**\\nChain: ${chain.charAt(0).toUpperCase() + chain.slice(1)}\\nExecution ID: \\`${executionId}\\`\\n\\n_Reply **confirm** to execute or **cancel** to abort._`}}];\n} catch (error) {\n  return [{json: {reply: `**Error creating send request**: ${error.message}`}}];\n}"
      }
    },
    {
      "id": "format-help",
      "name": "Format Help Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 700],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "return [{json: {reply: `**PigAiBank Commands**\\n\\n**Check Balance**\\n\"What's our balance?\" or \"balance\"\\n\\n**Check Prices**\\n\"ETH price\" or \"What's the price of ETH?\"\\n\\n**Swap Tokens**\\n\"Swap 100 USDC to ETH\"\\n\\n**Deposit USDC**\\n\"Deposit $100\" or \"Deposit 50 on Base\"\\n\\n**Send Funds**\\n\"Send 50 USDC to vitalik.eth\"\\n\\n_Powered by Circle Gateway, Uniswap, and LI.FI_`}}];"
      }
    },
    {
      "id": "format-unknown",
      "name": "Format Unknown Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 850],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "const content = $input.first().json.originalContent || '';\nconst intent = $input.first().json.intent;\nconst llmReply = $input.first().json.llmReply || '';\n\n// Use LLM-generated reply if available\nif (llmReply) {\n  return [{json: {reply: llmReply}}];\n}\n\n// Fallback to hardcoded responses\nif (intent === 'greeting') {\n  return [{json: {reply: `Hey! I'm PigAiBank. I can help you check balances, prices, execute swaps, and deposit USDC. Try \"balance\" or \"help\" to get started!`}}];\n}\nreturn [{json: {reply: `I'm not sure what you mean by \"${content.substring(0, 50)}\"...\\n\\nTry \"help\" to see what I can do!`}}];"
      }
    },
    {
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1250, 400],
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      }
    }
  ],
  "connections": {
    "Discord Command Webhook": {
      "main": [[{"node": "Parse Intent", "type": "main", "index": 0}]]
    },
    "Parse Intent": {
      "main": [[{"node": "Route by Intent", "type": "main", "index": 0}]]
    },
    "Route by Intent": {
      "main": [
        [{"node": "Get Gateway Balance", "type": "main", "index": 0}],
        [{"node": "Get ETH Price", "type": "main", "index": 0}],
        [{"node": "Create Swap Quote", "type": "main", "index": 0}],
        [{"node": "Handle Deposit", "type": "main", "index": 0}],
        [{"node": "Check if ENS", "type": "main", "index": 0}],
        [{"node": "Format Help Response", "type": "main", "index": 0}],
        [{"node": "Handle Confirm/Cancel", "type": "main", "index": 0}],
        [{"node": "Format Unknown Response", "type": "main", "index": 0}]
      ]
    },
    "Get Gateway Balance": {
      "main": [[{"node": "Format Balance Response", "type": "main", "index": 0}]]
    },
    "Get ETH Price": {
      "main": [[{"node": "Format Price Response", "type": "main", "index": 0}]]
    },
    "Format Balance Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Format Price Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Create Swap Quote": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Handle Confirm/Cancel": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Handle Deposit": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Check if ENS": {
      "main": [
        [{"node": "Resolve ENS Name", "type": "main", "index": 0}],
        [{"node": "Format Send (Address)", "type": "main", "index": 0}]
      ]
    },
    "Resolve ENS Name": {
      "main": [[{"node": "Format Send (ENS)", "type": "main", "index": 0}]]
    },
    "Format Send (ENS)": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Format Send (Address)": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Format Help Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "Format Unknown Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "pinData": {}
}
