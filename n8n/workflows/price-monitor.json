{
  "name": "Price Monitor",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "id": "trigger",
      "name": "Every 5 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [0, 0]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://gateway.thegraph.com/api/{{ $env.GRAPH_API_KEY }}/subgraphs/id/{{ $env.GRAPH_SUBGRAPH_BASE || 'FQ6JYszEKApsBpAmiHesRsd9Ygc6mzmpNRANeVQFYoVX' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"query\": \"{ pools(first: 1, where: { token0_: { symbol: \\\"WETH\\\" }, token1_: { symbol: \\\"USDC\\\" } }, orderBy: totalValueLockedUSD, orderDirection: desc) { token0Price token1Price totalValueLockedUSD } }\"\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "fetch-price",
      "name": "Fetch ETH Price (The Graph)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [220, 0],
      "onError": "continueRegularOutput",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Parse price and check against thresholds\nconst items = $input.all();\nconst response = items[0]?.json || {};\n\n// Parse ETH price from The Graph response\nlet price = 0;\nif (response.data?.pools?.[0]) {\n  const pool = response.data.pools[0];\n  // token1Price gives USDC per WETH\n  price = parseFloat(pool.token1Price) || 0;\n}\n\nif (price === 0) {\n  // Return error result if price fetch failed\n  return [{\n    json: {\n      token: 'ETH',\n      price: 0,\n      alertType: 'fetch_error',\n      severity: 'warning',\n      message: 'Failed to fetch ETH price from The Graph',\n      shouldAlert: true,\n      source: 'thegraph_uniswap_base',\n      timestamp: new Date().toISOString(),\n    }\n  }];\n}\n\nconst token = 'ETH';\n\n// Default thresholds - can be overridden via environment\nconst highThreshold = parseFloat($env.PRICE_ALERT_HIGH) || 4000;\nconst lowThreshold = parseFloat($env.PRICE_ALERT_LOW) || 2500;\n\nlet alertType = null;\nlet severity = 'warning';\nlet message = '';\n\nif (price >= highThreshold) {\n  alertType = 'price_high';\n  message = `${token} price ($${price.toFixed(2)}) exceeded high threshold ($${highThreshold})`;\n  severity = 'warning';\n} else if (price <= lowThreshold) {\n  alertType = 'price_low';\n  message = `${token} price ($${price.toFixed(2)}) dropped below low threshold ($${lowThreshold})`;\n  severity = 'critical';\n}\n\nreturn [{\n  json: {\n    token,\n    price,\n    alertType,\n    severity,\n    message,\n    shouldAlert: alertType !== null,\n    highThreshold,\n    lowThreshold,\n    source: 'thegraph_uniswap_base',\n    timestamp: new Date().toISOString(),\n  }\n}];"
      },
      "id": "check-thresholds",
      "name": "Check Thresholds",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 0]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-alert",
              "leftValue": "={{ $json.shouldAlert }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-alert",
      "name": "Should Alert?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [660, 0]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.DISCORD_WEBHOOK_ALERTS }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"embeds\": [{\n    \"title\": \"Price Alert\",\n    \"description\": \"{{ $json.message }}\",\n    \"color\": {{ $json.severity === 'critical' ? 15158332 : 16776960 }},\n    \"fields\": [\n      {\n        \"name\": \"Token\",\n        \"value\": \"{{ $json.token }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Current Price\",\n        \"value\": \"${{ $json.price.toFixed(2) }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Alert Type\",\n        \"value\": \"{{ $json.alertType }}\",\n        \"inline\": true\n      },\n      {\n        \"name\": \"Thresholds\",\n        \"value\": \"High: ${{ $json.highThreshold }} | Low: ${{ $json.lowThreshold }}\",\n        \"inline\": false\n      }\n    ],\n    \"footer\": {\n      \"text\": \"Treasury Ops Bot | Source: {{ $json.source }}\"\n    },\n    \"timestamp\": \"{{ $json.timestamp }}\"\n  }]\n}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "discord-alert",
      "name": "Send Alert to Discord",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [880, -100],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Save alert to Appwrite\nconst items = $input.all();\nconst data = items[0]?.json || {};\n\nconst endpoint = $env.APPWRITE_ENDPOINT;\nconst projectId = $env.APPWRITE_PROJECT_ID;\nconst apiKey = $env.APPWRITE_API_KEY;\nconst databaseId = $env.APPWRITE_DATABASE_ID || 'treasury';\n\nif (!endpoint || !apiKey) {\n  return [{ json: { saved: false, reason: 'Appwrite not configured' } }];\n}\n\ntry {\n  const response = await fetch(\n    `${endpoint}/databases/${databaseId}/collections/alerts/documents`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n      body: JSON.stringify({\n        documentId: 'unique()',\n        data: {\n          timestamp: data.timestamp,\n          type: data.alertType || 'unknown',\n          severity: data.severity || 'warning',\n          message: data.message || '',\n          token: data.token || '',\n          threshold: data.alertType === 'price_high' ? data.highThreshold : data.lowThreshold,\n          actual_value: data.price || 0,\n          acknowledged: false,\n        },\n      }),\n    }\n  );\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    return [{ json: { saved: false, reason: errorText } }];\n  }\n\n  return [{ json: { saved: true } }];\n} catch (error) {\n  return [{ json: { saved: false, reason: error.message } }];\n}"
      },
      "id": "save-alert",
      "name": "Save Alert to Appwrite",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [880, 100]
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Always save price to history\nconst items = $input.all();\n\n// Get data from Check Thresholds node\nlet data;\ntry {\n  data = $('Check Thresholds').first()?.json || {};\n} catch (e) {\n  data = items[0]?.json || {};\n}\n\nconst endpoint = $env.APPWRITE_ENDPOINT;\nconst projectId = $env.APPWRITE_PROJECT_ID;\nconst apiKey = $env.APPWRITE_API_KEY;\nconst databaseId = $env.APPWRITE_DATABASE_ID || 'treasury';\n\nif (!endpoint || !apiKey) {\n  return [{ json: { saved: false, reason: 'Appwrite not configured' } }];\n}\n\nif (!data.price || data.price === 0) {\n  return [{ json: { saved: false, reason: 'No valid price to save' } }];\n}\n\ntry {\n  const response = await fetch(\n    `${endpoint}/databases/${databaseId}/collections/price_history/documents`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Appwrite-Project': projectId,\n        'X-Appwrite-Key': apiKey,\n      },\n      body: JSON.stringify({\n        documentId: 'unique()',\n        data: {\n          timestamp: data.timestamp || new Date().toISOString(),\n          token: data.token || 'ETH',\n          price_usd: data.price,\n          source: data.source || 'thegraph_uniswap_base',\n        },\n      }),\n    }\n  );\n\n  if (!response.ok) {\n    const errorText = await response.text();\n    return [{ json: { saved: false, reason: errorText } }];\n  }\n\n  return [{ json: { saved: true, price: data.price } }];\n} catch (error) {\n  return [{ json: { saved: false, reason: error.message } }];\n}"
      },
      "id": "save-price",
      "name": "Save Price to History",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 200]
    }
  ],
  "connections": {
    "Every 5 Minutes": {
      "main": [
        [{ "node": "Fetch ETH Price (The Graph)", "type": "main", "index": 0 }]
      ]
    },
    "Fetch ETH Price (The Graph)": {
      "main": [
        [{ "node": "Check Thresholds", "type": "main", "index": 0 }]
      ]
    },
    "Check Thresholds": {
      "main": [
        [
          { "node": "Should Alert?", "type": "main", "index": 0 },
          { "node": "Save Price to History", "type": "main", "index": 0 }
        ]
      ]
    },
    "Should Alert?": {
      "main": [
        [
          { "node": "Send Alert to Discord", "type": "main", "index": 0 },
          { "node": "Save Alert to Appwrite", "type": "main", "index": 0 }
        ],
        []
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "pinData": {}
}
